<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>外部プログラムの実行 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="variables.html">Variables</a></li><li><a class="tocitem" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="tocitem" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="functions.html">Functions</a></li><li><a class="tocitem" href="control-flow.html">Control Flow</a></li><li><a class="tocitem" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="types.html">型</a></li><li><a class="tocitem" href="methods.html">Methods</a></li><li><a class="tocitem" href="constructors.html">Constructors</a></li><li><a class="tocitem" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li><a class="tocitem" href="modules.html">Modules</a></li><li><a class="tocitem" href="documentation.html">Documentation</a></li><li><a class="tocitem" href="metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="missing.html">Missing Values</a></li><li><a class="tocitem" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="parallel-computing.html">並列計算</a></li><li><a class="tocitem" href="asynchronous-programming.html">非同期プログラミング</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="distributed-computing.html">複数プロセス処理と分散計算</a></li><li class="is-active"><a class="tocitem" href="running-external-programs.html">外部プログラムの実行</a><ul class="internal"><li><a class="tocitem" href="#command-interpolation"><span>補間</span></a></li><li><a class="tocitem" href="#引用"><span>引用</span></a></li><li><a class="tocitem" href="#パイプライン"><span>パイプライン</span></a></li></ul></li><li><a class="tocitem" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="handling-operating-system-variation.html">OSの違いへの対応</a></li><li><a class="tocitem" href="environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="code-loading.html">コードの読み込み</a></li><li><a class="tocitem" href="profile.html">プロファイリング</a></li><li><a class="tocitem" href="stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="performance-tips.html">パフォーマンスのヒント</a></li><li><a class="tocitem" href="workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="style-guide.html">Style Guide</a></li><li><a class="tocitem" href="faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="unicode-input.html">Unicode Input</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="running-external-programs.html">外部プログラムの実行</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="running-external-programs.html">外部プログラムの実行</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fms-lab/julia-doc-ja/blob/main/doc/src/manual/running-external-programs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Running-External-Programs"><a class="docs-heading-anchor" href="#Running-External-Programs">外部プログラムの実行</a><a id="Running-External-Programs-1"></a><a class="docs-heading-anchor-permalink" href="#Running-External-Programs" title="Permalink"></a></h1><p>JuliaはShell，Perl，Rubyのコマンドのバックティック記法を借用しています．しかしJuliaで以下のような書き方</p><pre><code class="language-julia-repl">julia&gt; `echo hello`
`echo hello`</code></pre><p>をすると，様々なShellやPerl,Rubyでの動作といくつかの点で異なるものになります:</p><ul><li>コマンドをすぐに実行するのではなく，バックティックはコマンドを表わす<a href="../base/base.html#Base.Cmd"><code>Cmd</code></a>オブジェクトを作成します．このオブジェクトを使ってパイプを介してそれを<a href="../base/base.html#Base.run"><code>run</code></a>したり，<a href="../base/io-network.html#Base.read"><code>read</code></a>や<a href="../base/io-network.html#Base.write"><code>write</code></a>したりすることができます．</li><li>コマンドが実行されると，特に指定しない限り，Juliaはその出力をキャプチャしません．その代わりに，コマンドの出力は<code>libc</code>の<code>system</code>コールを使用した場合と同様にデフォルトで<a href="../base/io-network.html#Base.stdout"><code>stdout</code></a>に出力されます．</li><li>コマンドはシェルで実行されることはありません．代わりにJuliaはコマンドの構文を直接解析し，シェルの引用構文を尊重しながら，シェルが行うように変数を適切に補間したり，単語を分割したりします．コマンドは<code>julia</code>の直系の子プロセスとして実行され，<code>fork</code>と<code>exec</code>呼び出しを使用します．</li></ul><p>ここに外部プログラムを実行する簡単な例があります:</p><pre><code class="language-julia-repl">julia&gt; mycommand = `echo hello`
`echo hello`

julia&gt; typeof(mycommand)
Cmd

julia&gt; run(mycommand);
hello</code></pre><p><code>hello</code>は<a href="../base/io-network.html#Base.stdout"><code>stdout</code></a>に送られた<code>echo</code>コマンドの出力です．runメソッドそのものは<code>nothing</code>を返し， 外部コマンドの実行に失敗した場合には<a href="../base/base.html#Core.ErrorException"><code>ErrorException</code></a>をスローします．</p><p>外部コマンドの出力を読み込みたい場合には，代わりに<a href="../base/io-network.html#Base.read"><code>read</code></a>を使用することができます:</p><pre><code class="language-julia-repl">julia&gt; a = read(`echo hello`, String)
&quot;hello\n&quot;

julia&gt; chomp(a) == &quot;hello&quot;
true</code></pre><p>より一般的には，<a href="../base/io-network.html#Base.open"><code>open</code></a>を使用して外部コマンドを読み込んだり書き込んだりすることができます．</p><pre><code class="language-julia-repl">julia&gt; open(`less`, &quot;w&quot;, stdout) do io
           for i = 1:3
               println(io, i)
           end
       end
1
2
3</code></pre><p>プログラム名とコマンド内の個々の引数にアクセスして，あたかもコマンドが文字列の配列であるかのように反復処理することができます．</p><pre><code class="language-julia-repl">julia&gt; collect(`echo &quot;foo bar&quot;`)
2-element Array{String,1}:
 &quot;echo&quot;
 &quot;foo bar&quot;

julia&gt; `echo &quot;foo bar&quot;`[2]
&quot;foo bar&quot;</code></pre><h2 id="command-interpolation"><a class="docs-heading-anchor" href="#command-interpolation">補間</a><a id="command-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#command-interpolation" title="Permalink"></a></h2><p>もう少し複雑なことをして，変数<code>file</code>のファイル名をコマンドの引数として使いたいとしましょう． 文字列リテラルの場合と同じように，補間に<code>$</code>を使うことができます（<a href="../devdocs/ast.html#Strings">Strings</a>を参照してください）．</p><pre><code class="language-julia-repl">julia&gt; file = &quot;/etc/passwd&quot;
&quot;/etc/passwd&quot;

julia&gt; `sort $file`
`sort /etc/passwd`</code></pre><p>シェル経由で外部プログラムを実行する際によくある落とし穴は，ファイル名にシェルにとって特別な 文字が含まれている場合に，望ましくない動作を引き起こす可能性があるということです．例えば， <code>/etc/passwd</code>の代わりに，<code>/Volumes/External HD/data.csv</code>というファイルの内容をソートしたいと します．試してみましょう:</p><pre><code class="language-julia-repl">julia&gt; file = &quot;/Volumes/External HD/data.csv&quot;
&quot;/Volumes/External HD/data.csv&quot;

julia&gt; `sort $file`
`sort &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>ファイル名はどうやって引用されたのでしょうか？Juliaは<code>file</code>が一つの引数として補間されること を知っているので，その言葉を引用しています．実際にはこれは正確ではありません．<code>file</code>の値は シェルによって解釈されることはありませんので，実際の引用の必要はありません．引用が挿入される のはユーザに提示するためだけです．これはシェルの単語の一部として値を補間しても動作します:</p><pre><code class="language-julia-repl">julia&gt; path = &quot;/Volumes/External HD&quot;
&quot;/Volumes/External HD&quot;

julia&gt; name = &quot;data&quot;
&quot;data&quot;

julia&gt; ext = &quot;csv&quot;
&quot;csv&quot;

julia&gt; `sort $path/$name.$ext`
`sort &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>ご覧のように，<code>path</code>変数のスペースは適切にエスケープされています．しかし，複数の単語を補間 したい場合はどうでしょうか？その場合は，配列（またはその他の反復可能なコンテナ）を使用します:</p><pre><code class="language-julia-repl">julia&gt; files = [&quot;/etc/passwd&quot;,&quot;/Volumes/External HD/data.csv&quot;]
2-element Array{String,1}:
 &quot;/etc/passwd&quot;
 &quot;/Volumes/External HD/data.csv&quot;

julia&gt; `grep foo $files`
`grep foo /etc/passwd &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>シェルの単語の一部として配列を補間すると，Juliaはシェルの<code>{a,b,c}</code>引数生成をエミュレートします:</p><pre><code class="language-julia-repl">julia&gt; names = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
3-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;
 &quot;baz&quot;

julia&gt; `grep xylophone $names.txt`
`grep xylophone foo.txt bar.txt baz.txt`</code></pre><p>さらに，複数の配列を同じ単語に補間すると，シェルのデカルト積生成動作がエミュレートされます:</p><pre><code class="language-julia-repl">julia&gt; names = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
3-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;
 &quot;baz&quot;

julia&gt; exts = [&quot;aux&quot;,&quot;log&quot;]
2-element Array{String,1}:
 &quot;aux&quot;
 &quot;log&quot;

julia&gt; `rm -f $names.$exts`
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`</code></pre><p>リテラル配列を補間できるので，最初に一時的な配列オブジェクトを作成しなくても，この生成機能を使うことができます．</p><pre><code class="language-julia-repl">julia&gt; `rm -rf $[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;,&quot;qux&quot;].$[&quot;aux&quot;,&quot;log&quot;,&quot;pdf&quot;]`
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`</code></pre><h2 id="引用"><a class="docs-heading-anchor" href="#引用">引用</a><a id="引用-1"></a><a class="docs-heading-anchor-permalink" href="#引用" title="Permalink"></a></h2><p>必然的に，それほど単純ではないコマンドを書きたくなって，引用符を使う必要が出てきます． ここでは，シェルプロンプトでのPerlのワンライナの簡単な例を示します:</p><pre><code class="language-none">sh$ perl -le &#39;$|=1; for (0..3) { print }&#39;
0
1
2
3</code></pre><p>スペースが式を複数のシェルワードに分割しないようにするためと，<code>$|</code>のようなPerlの変数（これは Perlの変数名です）を使用しても補間が発生しないようにするためです．他の例では，補間が<em>発生する</em> ように二重引用符を使用したい場合もあるでしょう:</p><pre><code class="language-none">sh$ first=&quot;A&quot;
sh$ second=&quot;B&quot;
sh$ perl -le &#39;$|=1; print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;
1: A
2: B</code></pre><p>一般的に，Juliaのバックティック構文は慎重に設計されているので，シェルコマンドをそのまま バックティックにカットアンドペーストするだけで動作するようになっています．エスケープ，引用， 補間の動作はシェルのものと同じです．唯一の違いは，補間が統合されており，何が単一の文字列で 何が複数の値のためのコンテナであるかというJuliaの概念を認識しているということです．上記2つ の例をJuliaで試してみましょう:</p><pre><code class="language-julia-repl">julia&gt; A = `perl -le &#39;$|=1; for (0..3) { print }&#39;`
`perl -le &#39;$|=1; for (0..3) { print }&#39;`

julia&gt; run(A);
0
1
2
3

julia&gt; first = &quot;A&quot;; second = &quot;B&quot;;

julia&gt; B = `perl -le &#39;print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;`
`perl -le &#39;print for @ARGV&#39; &#39;1: A&#39; &#39;2: B&#39;`

julia&gt; run(B);
1: A
2: B</code></pre><p>結果は同じで，ほとんどのシェルがスペースで分割された文字列を使用して曖昧さを出してしまう一方， Juliaは素晴らしい反復可能オブジェクトをサポートしているという事実から，Juliaの補間動作は シェルのものをいくらか改善しながら真似ています．シェルコマンドをJuliaに移植使用とする時は， まずはカットアンドペーストを試してみてください．Juliaコマンドを実行する前にコマンドを見せて くれるので，ダメージを与えることなく，簡単かつ安全にコメントの解釈を調べることができます．</p><h2 id="パイプライン"><a class="docs-heading-anchor" href="#パイプライン">パイプライン</a><a id="パイプライン-1"></a><a class="docs-heading-anchor-permalink" href="#パイプライン" title="Permalink"></a></h2><p><code>|</code>や<code>&amp;</code>，<code>&gt;</code>といったシェルのメタ文字は，Juliaのバックティックの中では引用符を付けるか， エスケープする必要があります:</p><pre><code class="language-julia-repl">julia&gt; run(`echo hello &#39;|&#39; sort`);
hello | sort

julia&gt; run(`echo hello \| sort`);
hello | sort</code></pre><p>この式は3つのワード<code>hello</code>，<code>|</code>，<code>sort</code>を引数として<code>echo</code>コマンドを呼び出します．その結果， <code>hello | sort</code>という一行が表示されます．では，どのようにしてパイプラインを構築するのでしょうか？ バックティックの中で，<code>|</code>を使うかわりに，<a href="../base/base.html#Base.pipeline-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>pipeline</code></a>を使います．</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`echo hello`, `sort`));
hello</code></pre><p>これは<code>echo</code>コマンドwを<code>sort</code>コマンドにパイプします．もちろん，これはソートする行が一行しか ないので，あまり面白いものではありませんが，実際もっと面白いことができます:</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))
210
211
212
213
214</code></pre><p>これは，UNIXシステム上のユーザIDのうち，上位5つのユーザIDを表示します．<code>cut</code>，<code>sort</code>，<code>tail</code> コマンドは全て現在の<code>julia</code>プロセスの即席子プロセスとして生成され，シェルプロセスは介在 しません．通常シェルが行うパイプの設定やファイルディスクリプタの接続は，Julia自身が行い ます．Julia自身がこれを行うので，より良い制御を保持し，シェルにはできないことを行うことが できます．</p><p>Juliaは複数のコマンドを並列に実行することができます:</p><pre><code class="language-julia-repl">julia&gt; run(`echo hello` &amp; `echo world`);
world
hello</code></pre><p>2つの<code>echo</code>プロセスはほぼ同時に実行され，お互いに共有している<a href="../base/io-network.html#Base.stdout"><code>stdout</code></a>ディスクリプタ と<code>julia</code>親プロセスへの最初の書き込みを競って行うため，ここでの出力の順序は決定性がありませ ん．Juliaではこれら両方のプロセスからの出力を別のプログラムにパイプすることができます:</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`echo world` &amp; `echo hello`, `sort`));
hello
world</code></pre><p>UNIXの配管の観点から見て，ここで何が起こっているのかというと，両方の<code>echo</code>プロセスによって 単一のUNIXパイプオブジェクトが作成されて書き込まれ，パイプのもう一方の端が<code>sort</code>コマンド によって読み込まれるということになっています．</p><p>IOリダイレクトは，キーワード変数<code>stdin</code>，<code>stdout</code>，<code>stderr</code>を<code>pipeline</code>関数に渡すことで実現できます:</p><pre><code class="language-julia">pipeline(`do_work`, stdout=pipeline(`sort`, &quot;out.txt&quot;), stderr=&quot;errs.txt&quot;)</code></pre><h3 id="パイプラインでのデッドロックを避ける"><a class="docs-heading-anchor" href="#パイプラインでのデッドロックを避ける">パイプラインでのデッドロックを避ける</a><a id="パイプラインでのデッドロックを避ける-1"></a><a class="docs-heading-anchor-permalink" href="#パイプラインでのデッドロックを避ける" title="Permalink"></a></h3><p>単一プロセスからパイプラインの両端に読み書きする場合，カーネルが全てのデータをバッファリング することを強制しないようにすることが重要です．</p><p>例えば，コマンドからの出力を全て読み込む場合は，<code>wait(process)</code>ではなく，<code>read(out, String)</code> を呼び出してください．なぜなら，前者はプロセスによって書き込まれた全てのデータを積極的に 消費するのに対し，後者はリーダが接続されるのを待っている間にカーネルのバッファにデータを 保存しようとするからです．</p><p>もう一つの一般的な解決策は，パイプラインのリーダとライタを別々の<a href="../base/parallel.html#Core.Task"><code>Task</code></a>sに分離することです:</p><pre><code class="language-julia">writer = @async write(process, &quot;data&quot;)
reader = @async do_compute(read(process, String))
wait(writer)
fetch(reader)</code></pre><h3 id="複雑な例"><a class="docs-heading-anchor" href="#複雑な例">複雑な例</a><a id="複雑な例-1"></a><a class="docs-heading-anchor-permalink" href="#複雑な例" title="Permalink"></a></h3><p>高レベルのプログラミング言語，素晴らしいコマンド抽象化，そしてプロセス間の自動セットアップ の組み合わせは強力なものです．簡単に作成できる複雑なパイプラインを理解してもらうために， ここではより洗練された例をいくつか紹介します．Perlのワンライナを多用しすぎたことをお詫び しておきます:</p><pre><code class="language-julia-repl">julia&gt; prefixer(prefix, sleep) = `perl -nle &#39;$|=1; print &quot;&#39;$prefix&#39; &quot;, $_; sleep &#39;$sleep&#39;;&#39;`;

julia&gt; run(pipeline(`perl -le &#39;$|=1; for(0..5){ print; sleep 1 }&#39;`, prefixer(&quot;A&quot;,2) &amp; prefixer(&quot;B&quot;,2)));
B 0
A 1
B 2
A 3
B 4
A 5</code></pre><p>これは1つのプロデューサが2つの並行したコンシューマに同時に供給している例です．1つのPerl プロセスが0から5までの数字が書かれた行を生成し，2つの並列プロセスがその出力を消費して います．片方は行を「A」でプレフィックスし，もう片方は「B」でプレフィックスいます． どちらが最初の行を取得するかは非決定論的ですが，その競争に勝利すると，行は一方のプロセス ともう一方のプロセスによって交互に消費されます．（Perlで<code>$|=1</code>を設定すると，各print文は <a href="../base/io-network.html#Base.stdout"><code>stdout</code></a>ハンドルをフラッシュするようになります．これはこの例が動作するのに必要 なことで，そうしないと全ての出力はバッファリングされてパイプに一度だけプリントされ，1つの コンシューマプロセスだけからしか読めないようになってしまいます．）</p><p>ここでは更に複雑な多段のプロデューサとコンシューマの例を示します:</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`perl -le &#39;$|=1; for(0..5){ print; sleep 1 }&#39;`,
           prefixer(&quot;X&quot;,3) &amp; prefixer(&quot;Y&quot;,3) &amp; prefixer(&quot;Z&quot;,3),
           prefixer(&quot;A&quot;,2) &amp; prefixer(&quot;B&quot;,2)));
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5</code></pre><p>この例は前の例に似ていますが，コンシューマの2つのステージがあり，各ステージは異なる レイテンシを持っているので，飽和したスループットを維持するために異なる数の並列ワーカ を使用します．</p><p>これらの例を全て試してみて，どのように動作するかを確認することを強くお勧めします．</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="distributed-computing.html">« 複数プロセス処理と分散計算</a><a class="docs-footer-nextpage" href="calling-c-and-fortran-code.html">Calling C and Fortran Code »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 17 June 2021 11:15">Thursday 17 June 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
