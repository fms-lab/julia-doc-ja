<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>プロファイリング · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="variables.html">Variables</a></li><li><a class="tocitem" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="functions.html">Functions</a></li><li><a class="tocitem" href="control-flow.html">Control Flow</a></li><li><a class="tocitem" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="types.html">Types</a></li><li><a class="tocitem" href="methods.html">Methods</a></li><li><a class="tocitem" href="constructors.html">Constructors</a></li><li><a class="tocitem" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li><a class="tocitem" href="modules.html">Modules</a></li><li><a class="tocitem" href="documentation.html">Documentation</a></li><li><a class="tocitem" href="metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="missing.html">Missing Values</a></li><li><a class="tocitem" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="parallel-computing.html">並列計算</a></li><li><a class="tocitem" href="asynchronous-programming.html">非同期プログラミング</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="distributed-computing.html">複数プロセス処理と分散計算</a></li><li><a class="tocitem" href="running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="handling-operating-system-variation.html">OSの違いへの対応</a></li><li><a class="tocitem" href="environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="code-loading.html">コードの読み込み</a></li><li class="is-active"><a class="tocitem" href="profile.html">プロファイリング</a><ul class="internal"><li><a class="tocitem" href="#基本的な用法"><span>基本的な用法</span></a></li><li><a class="tocitem" href="#蓄積とクリア"><span>蓄積とクリア</span></a></li><li><a class="tocitem" href="#プロファイル結果表示の制御オプション"><span>プロファイル結果表示の制御オプション</span></a></li><li><a class="tocitem" href="#コンフィグ"><span>コンフィグ</span></a></li><li class="toplevel"><a class="tocitem" href="#Memory-allocation-analysis"><span>メモリ割り当ての解析</span></a></li><li class="toplevel"><a class="tocitem" href="#外部のプロファイリングツール"><span>外部のプロファイリングツール</span></a></li></ul></li><li><a class="tocitem" href="stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="style-guide.html">Style Guide</a></li><li><a class="tocitem" href="faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="unicode-input.html">Unicode Input</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="profile.html">プロファイリング</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="profile.html">プロファイリング</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fms-lab/julia-doc-ja/blob/main/doc/src/manual/profile.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Profiling"><a class="docs-heading-anchor" href="#Profiling">プロファイリング</a><a id="Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling" title="Permalink"></a></h1><p><code>Profile</code>は開発者に，コードのパフォーマンスを向上させるためのツールを提供します． 使用すると，実行中のコードを測定し，個々の行にどれだけの時間が費やされているかを理解するのに 役立つ出力を生成します．最も一般的な使用法は，最適化の対象となる「ボトルネック」を特定することです．</p><p><code>Profile</code>は「サンプリング」や[statistical profiler](https://en.wiki<br/>pedia.org/wiki/Profiling<em>(computer</em>programming)) として知られているものを実装しています．これは任意のタスクの実行中に定期的にバックトレースを 取ることで動作します．各バックトレースは現在実行中の関数と行番号に加えて，その行につながった 関数呼び出しの完全な連鎖をキャプチャし，現在の実行状態の「スナップショット」となります．</p><p>実行時間の多くが特定のコード行の実行に費やされている場合，この行は全てのバックトレースの セットに頻繁に表示されます．つまり，この行を含む一連の関数呼び出しのコストは，その行が 全てのバックトレースのセットの中で表示される頻度に比例します．</p><p>サンプリングプロファイラは，バックトレースが感覚をおいて発生するため，行ごとに完全にカバー することはできません（デフォルトでは，Unixでは1ms，Windowsでは10msとなっていますが，実際の スケジューリングはOSの負荷に左右されます）．さらに，後述するように，全ての実行ポイントの 疎なサブセットで収集されるため，サンプリングプロファイラによって収集されたデータは統計的 なノイズの影響を受けます．</p><p>これらの制約にも拘わらず，サンプリングプロファイラには大きな強みがあります:</p><ul><li>タイミング測定のためにコードを変更する必要がありません．</li><li>サンプリングプロファイラは，Juliaのコアコードや，（オプションで）CやFortranのライブラリをプロファイリングすることができます．</li><li>頻繁に実行しないことにより，パフォーマンスへのオーバーヘッドはほとんどなく，プロファイリングを行っている間，コードはほぼネイティブなスピードで実行できます．</li></ul><p>これらの理由から，他の方法を検討する前に，組み込みのサンプリングプロファイラを使用してみることをお勧めします．</p><h2 id="基本的な用法"><a class="docs-heading-anchor" href="#基本的な用法">基本的な用法</a><a id="基本的な用法-1"></a><a class="docs-heading-anchor-permalink" href="#基本的な用法" title="Permalink"></a></h2><p>簡単なテストケースを見てみましょう:</p><pre><code class="language-julia-repl">julia&gt; function myfunc()
           A = rand(200, 200, 400)
           maximum(A)
       end</code></pre><p>（JuliaのJITコンパイラをプロファイリングしたい場合を除いて）プロファイリングするコードを はじめに少なくとも一度は実行しておくことをお勧めします．</p><pre><code class="language-julia-repl">julia&gt; myfunc() # run once to force compilation</code></pre><p>さて，この関数をプロファイリングする準備ができました:</p><pre><code class="language-julia-repl">julia&gt; using Profile

julia&gt; @profile myfunc()</code></pre><p>プロファイリング結果を見るために，いくつかのグラフィカルブラウザがあります． ビジュアライザの「ファミリ」の一つは，<a href="https://github.com/timholy/FlameGraphs.jl">FlameGraphs.jl</a>に 基づいており，各ファミリのメンバは異なるユーザインタフェースを提供しています:</p><ul><li><a href="https://junolab.org/">Juno</a>はプロファイルの可視化をビルトインでサポートする完全なIDEです</li><li><a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a>はGTKをベースにしたスタンドアロンのビジュアライザです</li><li><a href="https://github.com/davidanthoff/ProfileVega.jl">ProfileVega.jl</a>はVegaLightを使用しており，Jupyter notebookとうまく統合されています</li><li><a href="https://github.com/tkluck/StatProfilerHTML.jl">StatProfilerHTML</a>はHTMLを生成し，いくつかの追加サマリを表示し，Jupyter notebookとの統合も可能です</li><li><a href="https://github.com/timholy/ProfileSVG.jl">ProfileSVG</a>はSVGをレンダリングします</li></ul><p>プロファイルの可視化のための完全に独立したアプローチとして，外部ツールである<code>pprof</code>を 使用する<a href="https://github.com/vchuravy/PProf.jl">PProf.jl</a>があります．</p><p>しかし，ここでは標準ライブラリに付属のテキストベースの表示を使用します:</p><pre><code class="language-julia-repl">julia&gt; Profile.print()
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
 80 ./REPL.jl:97; macro expansion
  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)
   80 ./boot.jl:235; eval(::Module, ::Any)
    80 ./&lt;missing&gt;:?; anonymous
     80 ./profile.jl:23; macro expansion
      52 ./REPL[1]:2; myfunc()
       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...
        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...
       14 ./random.jl:278; rand
        14 ./random.jl:277; rand
         14 ./random.jl:366; rand
          14 ./random.jl:369; rand
      28 ./REPL[1]:3; myfunc()
       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...
        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...</code></pre><p>この表示の各行は，コード内の特定の場所（行番号）を表しています．インデントは関数呼び出しの 入れ子になったシーケンスを示すために使用され，インデントが大きい行は呼び出しのシーケンスの 中でより深い位置にあることを示します．各行の最初の「フィールド」は，<em>この行またはその行で</em> 実行された関数のバックトレース（サンプル）の数です．2番目のフィールドはファイル名と行番号， 3番目のフィールドは関数名です．特定の行番号は，Juliaのコードの変更に伴って変更される可能性 があることに注意してください．この例を自分で実行しながら試してみるのが良いでしょう．</p><p>この例では，呼び出された最上位の関数が<code>event.jl</code>にあることがわかります．これはJuliaを起動 する時にREPLを実行する関数です．<code>REPL.jl</code>の97行目を調べると，関数<code>eval_user_input()</code>が呼び 出されていることがわかります．これはREPLで入力した内容を評価する関数で，対話的に作業している ため，<a href="../stdlib/Profile.html#Profile.@profile"><code>@profile</code></a>マクロで行われたアクションを反映しています．</p><p>1行目は，<code>event.jl</code>の73行目で80個のバックトレースが取られたことを示していますが，この行 自体が「高コスト」だったわけではありません．3行目を見ると，これら80個のバックトレースの 全てが実際に<code>eval_user_input</code>への呼び出しの中でトリガされていることなどがわかります． 実際にどの捜査に時間がかかっているのかを知るためには，コールチェインをもっと深く調べる 必要があります．</p><p>この出力の最初の「重要な」行はこの行です:</p><pre><code class="language-none">52 ./REPL[1]:2; myfunc()</code></pre><p><code>REPL</code>は<code>myfunc</code>をファイルに入れるのではなく，REPL内で<code>myfunc</code>を定義した事実を参照します． もしファイルを使っていたとしたら，これはファイル名を示すことになります．<code>[1]</code>は関数<code>myfunc</code> がこのREPLセッションで評価された最初の式であることを示しています．<code>myfunc()</code>の2行目には <code>rand</code>への呼び出しが含まれており，この行で発生したバックトレースは（80個中）52個ありました． その下には，<code>dSFMT.jl</code>内の<code>dsfmt_fill_array_close_open!</code>への呼び出しがあります．</p><p>もう少し下に行くと，以下のようになっています:</p><pre><code class="language-none">28 ./REPL[1]:3; myfunc()</code></pre><p><code>myfunc</code>の3行目には，<code>maximum</code>の呼び出しが含まれており，ここで取られたバックトレースは， （80個中）28個でした．その下に，このタイプの入力データへの<code>maximum</code>関数で時間のかかる 操作を実行している<code>base/reduce.jl</code>の特定の箇所を見ることができます．</p><p>全体的に，乱数の生成は，最大要素を見つけるのに比べて約2倍のコストがかかると仮に結論づける ことができます．より多くのサンプルを収集することで，この結果の信頼性を高めることができます:</p><pre><code class="language-julia-repl">julia&gt; @profile (for i = 1:100; myfunc(); end)

julia&gt; Profile.print()
[....]
 3821 ./REPL[1]:2; myfunc()
  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...
   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...
  310  ./random.jl:278; rand
   [....]
 2893 ./REPL[1]:3; myfunc()
  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...
   [....]</code></pre><p>一般的に，ある行で<code>N</code>個のサンプルを収集した場合，<code>sqrt(N)</code>オーダの不確かさが想定されます （コンピュータが他のタスクでどれくらいビジーかなど他のノイズ源を除く）．このルールの主要 な例外はガベージコレクションで，実行頻度は低いものの，非常に高コストになる傾向があります （JuliaのガベージコレクタはCで書かれているので，このようなイベントは後述の<code>C=true</code>出力 モードを使うか，<a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a>を使うことで 検出することができます）．</p><p>これはデフォルトの「ツリー」ダンプを示しています．別の方法として「フラット」ダンプがあり， ネスティングに依存せずにカウントを蓄積しています．</p><pre><code class="language-julia-repl">julia&gt; Profile.print(format=:flat)
 Count File          Line Function
  6714 ./&lt;missing&gt;     -1 anonymous
  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)
  6714 ./REPL.jl       97 macro expansion
  3821 ./REPL[1]        2 myfunc()
  2893 ./REPL[1]        3 myfunc()
  6714 ./REPL[7]        1 macro expansion
  6714 ./boot.jl      235 eval(::Module, ::Any)
  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...
  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
  6714 ./profile.jl    23 macro expansion
  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...
   310 ./random.jl    277 rand
   310 ./random.jl    278 rand
   310 ./random.jl    366 rand
   310 ./random.jl    369 rand
  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...
     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...</code></pre><p>コードに再帰性がある場合，混乱を招く可能性があるのは，「子」関数のある行がバックトレースの 総数よりも多くのカウントを蓄積する可能性があるということです．以下の関数定義を見てみましょう:</p><pre><code class="language-julia">dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)
dumbsum3() = dumbsum(3)</code></pre><p><code>dumbsum3</code>をプロファイリングし，それが<code>dumbsum(1)</code>で実行している間にバックトレースを取得した とすると，バックトレースは次のようになります:</p><pre><code class="language-julia">dumbsum3
    dumbsum(3)
        dumbsum(2)
            dumbsum(1)</code></pre><p>結果的に，この子関数は3つのカウントを取得しますが，親関数は1カウントだけ取得します． 「ツリー」表現はこれをより明確にしてくれますし，この理由から，（他のものと比べて）結果を 表示するための最も便利な方法と言うことができるでしょう．</p><h2 id="蓄積とクリア"><a class="docs-heading-anchor" href="#蓄積とクリア">蓄積とクリア</a><a id="蓄積とクリア-1"></a><a class="docs-heading-anchor-permalink" href="#蓄積とクリア" title="Permalink"></a></h2><p><a href="../stdlib/Profile.html#Profile.@profile"><code>@profile</code></a>の結果はバッファに蓄積されます．複数のコードを<a href="../stdlib/Profile.html#Profile.@profile"><code>@profile</code></a>の下で実行 すると，<a href="../stdlib/Profile.html#Profile.print"><code>Profile.print()</code></a>はその結果をまとめたものを表示します．これは非常に便利です が，時には新たにやり直したいこともあるでしょう．そのような時は，<a href="../stdlib/Profile.html#Profile.clear"><code>Profile.clear()</code></a>を 使うことができます．</p><h2 id="プロファイル結果表示の制御オプション"><a class="docs-heading-anchor" href="#プロファイル結果表示の制御オプション">プロファイル結果表示の制御オプション</a><a id="プロファイル結果表示の制御オプション-1"></a><a class="docs-heading-anchor-permalink" href="#プロファイル結果表示の制御オプション" title="Permalink"></a></h2><p><a href="../stdlib/Profile.html#Profile.print"><code>Profile.print</code></a>には，これまで説明してきた他にもオプションがあります．宣言の全てを見てみましょう:</p><pre><code class="language-julia">function print(io::IO = stdout, data = fetch(); kwargs...)</code></pre><p>まず初めに2つの位置指定引数を見て，その後キーワード引数を見てみましょう:</p><ul><li><p><code>io</code> – 結果をファイルなどのバッファに保存することができますが，デフォルトでは<code>stdout</code>（コンソール）に出力します．</p></li><li><p><code>data</code> – 分析したいデータを含みます．デフォルトでは<a href="../stdlib/Profile.html#Profile.fetch"><code>Profile.fetch()</code></a>から取得されますが，これはあらかじめ割り当てられたバッファからバックトレースを取り出します．例えば，プロファイラのプロファイルを作成したい場合には以下のようになります:</p><pre><code class="language-julia">data = copy(Profile.fetch())
Profile.clear()
@profile Profile.print(stdout, data) # Prints the previous results
Profile.print()                      # Prints results from Profile.print()</code></pre></li></ul><p>キーワード引数には，以下の任意の組み合わせを指定することができます:</p><ul><li><code>format</code> – 上で紹介したように，バックトレースを，木構造を示すインデントをつけて（デフォルト，<code>:tree</code>）表示するか，インデントなし（<code>:flat</code>）で表示するかを決定します．</li><li><code>C</code> – <code>true</code>の場合，CとFortranコードからのバックトレースを表示します（通常は除外されるものです）．例を<code>Profile.print(C = true)</code>をつけて実行してみてください．これはボトルネックの原因がJuliaコードなのか，Cコードなのかを判断するのに非常に役立ちます．<code>C = true</code>を設定するとネスティングの解釈性が向上しますが，プロファイルダンプが長くかかるようになります．</li><li><code>combine</code> – コードの一部の行には，複数の操作が含まれています．例えば，<code>s += A[i]</code>には，配列参照（<code>A[i]</code>）と，和演算の両方が含まれています．これらは生成されたマシンコードの別々の行に対応しているため，この行のバックトレース中に2つ以上の異なるアドレスがキャプチャされることがあります．<code>combine = true</code>はこれらをまとめて出力します．これはおそらく一般的に必要とされるものですが，<code>combine = false</code>とすることで，一意な命令ポインタごとに個別に出力を生成することができます．</li><li><code>maxdepth</code> – <code>:tree</code>フォーマットで<code>maxdepth</code>以上の深さにフレームを制限します．</li><li><code>sortedby</code> – <code>:flat</code>フォーマットの順序を制御します．<code>:filefuncline</code>（デフォルト）ではソース行でソートしますが，<code>:count</code>では収集したサンプル数の多い順にソートします．</li><li><code>noisefloor</code> – サンプルのヒューリスティックノイズフロア以下にフレームを制御します（<code>:tree</code>フォーマットにのみ適用されます）．この値の推奨値は2.0です（デフォルトは0）．このパラメータは，<code>n &lt;= noisefloor * √N</code>のサンプルを非表示にします（<code>n</code>はこの行のサンプル数，<code>N</code>は呼び出し先のサンプル数です．</li><li><code>mincount</code> – Limits frames with less than <code>mincount</code> occurrences.</li><li><code>mincount</code> – 発生回数が<code>mincount</code>未満のフレームに制限します．</li></ul><p>ファイルや関数の名前は時々（<code>...</code>で）丸められ，インデントは先頭の<code>+n</code>で丸められます． ここで<code>n</code>は，余裕があれば挿入される余分なスペースの数です．深くネストされている コードの完全なプロファイルが必要な場合は，<a href="../base/io-network.html#Base.IOContext"><code>IOContext</code></a>の広い<code>displaysize</code>を 使ってファイルに保存するのが良いアイデアです．</p><pre><code class="language-julia">open(&quot;/tmp/prof.txt&quot;, &quot;w&quot;) do s
    Profile.print(IOContext(s, :displaysize =&gt; (24, 500)))
end</code></pre><h2 id="コンフィグ"><a class="docs-heading-anchor" href="#コンフィグ">コンフィグ</a><a id="コンフィグ-1"></a><a class="docs-heading-anchor-permalink" href="#コンフィグ" title="Permalink"></a></h2><p><a href="../stdlib/Profile.html#Profile.@profile"><code>@profile</code></a>は単にバックトレースを蓄積するだけであり，分析は<a href="../stdlib/Profile.html#Profile.print"><code>Profile.print()</code></a> を呼び出すときに行われます．長時間実行される計算では，バックトレースを保存するために予め 割り当てられたバッファがいっぱいになってしまう可能性が十分にあります．そうなると， バックトレースは停止しますが，計算は続行されます．結果，重要なプロファイリングデータを 見逃してしまう場合があります（その場合は警告は表示されます）．</p><p>以下のようにして，関連するパラメータを取得して，設定することができます:</p><pre><code class="language-julia">Profile.init() # returns the current settings
Profile.init(n = 10^7, delay = 0.01)</code></pre><p><code>n</code>は格納できる命令ポインタの総数で，デフォルトの値は<code>10^6</code>です．一般的なバックトレースが 20命令ポインタだとすると，バックトレースを50000個集めることができ，統計的な不確実性は1%未満 となります．ほとんどのアプリケーションではこれで十分でしょう．</p><p>そのため，要求された計算を実行するために，Juliaがスナップショット間に取得する時間量を 設定するための，秒単位で表現される<code>delay</code>を修正する必要がある可能性が高くなります． 非常に長く実行されているジョブでは，頻繁にバックトレースを行う必要はないかもしれません． デフォルトの設定は<code>delay = 0.001</code>です．もちろん，遅延を増やすことも減らすこともできます． しかし遅延がバックトレースに必要な時間と同じくらい（筆者のラップトップでは30マイクロ秒程度） になると，プロファイリングのオーバーヘッドが大きくなります．</p><h1 id="Memory-allocation-analysis"><a class="docs-heading-anchor" href="#Memory-allocation-analysis">メモリ割り当ての解析</a><a id="Memory-allocation-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-allocation-analysis" title="Permalink"></a></h1><p>性能を向上させるための最も一般的なテクニックの一つは，メモリ割り当てを減らすことです． 総割り当て量は，<a href="../base/base.html#Base.@time"><code>@time</code></a>と<a href="../base/base.html#Base.@allocated"><code>@allocated</code></a>で測定でき，割り当てのトリガとなる 特定の行は，これらの行が発生するガベージコレクションのコストを介してプロファイリングから 推測することができます．しかし，コードの各行で割り当てられたメモリ量を直接測定した方が 効率が良い場合もあります．</p><p>行ごとに割り当てを測定するには，コマンドラインオプション<code>--track-allocation=&lt;setting&gt;</code>を つけてJuliaを起動します．その際，<code>none</code>（デフォルト．割り当てを測定しない），<code>user</code>（ Juliaのコアコード以外の全ての場所でメモリ割り当てを測定する），<code>all</code>（Juliaコードの各行 でメモリ割り当てを測定する）を選択できます．割り当てはコンパイルされたコードの各行ごとに 測定されます．Juliaを終了すると，累積結果はファイル名の後に<code>.mem</code>が付加されたテキスト ファイルに書き込まれ，ソースファイルと同じディレクトリに置かれます．各行には，割り当て られたバイト数の合計が表示されます．<a href="https://github.com/JuliaCI/Coverage.jl"><code>Coverage</code> package</a> パッケージには，割り当てられたバイト数の順に行を並べ替えるなど，いくつかの基本的な解析 ツールが含まれています．</p><p>結果を解釈する際には，いくつかの重要な詳細があります．<code>user</code>設定下では，REPLから直接呼び出さ れた関数の最初の行は，REPLコード自体で発生するイベントに起因する割り当てを示します．さらに 重要なことは，Juliaのコンパイラの多くはJuliaで書かれているため（なおかつコンパイルには通常メ モリ割り当てを必要とするため），JITコンパイルも割り当てカウントに追加されます．推奨される 手順は，解析したいコマンドを全て実行して強制的にコンパイルし，<a href="../stdlib/Profile.html#Profile.clear_malloc_data"><code>Profile.clear_malloc_data()</code></a> を呼び出して全ての割り当てカウンタをリセットすることです．最後に，目的のコマンドを実行し， Juliaを終了して，<code>.mem</code>ファイルの生成をトリガします．</p><h1 id="外部のプロファイリングツール"><a class="docs-heading-anchor" href="#外部のプロファイリングツール">外部のプロファイリングツール</a><a id="外部のプロファイリングツール-1"></a><a class="docs-heading-anchor-permalink" href="#外部のプロファイリングツール" title="Permalink"></a></h1><p>現在Juliaは外部プロファイリングツールとして，<code>Intel VTune</code>，<code>OProfile</code>，<code>perf</code>をサポートしています．</p><p>選択したツールに応じて，<code>Make.user</code>内で，<code>USE_INTEL_JITEVENTS</code>，<code>USE_OPROFILE_JITEVENTS</code>， <code>USE_PERF_JITEVENTS</code>を1に設定してコンパイルしてください．複数のフラグがサポートされています．</p><p>Juliaを実行する前に，環境変数<code>ENABLE_JITPROFILING</code>を1に設定してください．</p><p>これで，これらのツールを使用するための多くの方法が利用できるようになりました． 例えば<code>OProfile</code>を使って，単純な記録を試すことができます:</p><pre><code class="language-none">&gt;ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl
&gt;opreport -l `which ./julia`</code></pre><p>または，<code>perf</code>でも同様に以下のようにできます:</p><pre><code class="language-none">$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf ./julia /test/fastmath.jl
$ perf report --call-graph -G</code></pre><p>プログラムについて測定できる興味深い項目は他にもたくさんあります．完全なリストを得るためには <a href="http://www.brendangregg.com/perf.html">Linuxのperfの例のページ</a>を読んでください．</p><p>perfは各実行ごとに<code>perf.data</code>ファイルを保存しますが，これは小さなプログラムであっても非常に 大きくなることがあることも覚えておいてください．また，perf LLVMモジュールは<code>~/.debug/jit</code>に 一時的にデバッグオブジェクトを保存しますので，こまめにこのフォルダを消去することを覚えて おいてください．</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="code-loading.html">« コードの読み込み</a><a class="docs-footer-nextpage" href="stacktraces.html">Stack Traces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 17 January 2021 10:28">Sunday 17 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
