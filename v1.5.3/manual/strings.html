<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>文字列 · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="variables.html">Variables</a></li><li><a class="tocitem" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="tocitem" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li class="is-active"><a class="tocitem" href="strings.html">文字列</a><ul class="internal"><li><a class="tocitem" href="#man-characters"><span>文字</span></a></li><li><a class="tocitem" href="#String-Basics"><span>文字列の基本</span></a></li><li><a class="tocitem" href="#Unicode-and-UTF-8"><span>Unicode と UTF-8</span></a></li><li><a class="tocitem" href="#man-concatenation"><span>連結</span></a></li><li><a class="tocitem" href="#string-interpolation"><span>文字列補間</span></a></li><li><a class="tocitem" href="#Triple-Quoted-String-Literals"><span>トリプルクォーテーション付きの文字列リテラル</span></a></li><li><a class="tocitem" href="#Common-Operations"><span>よくある操作</span></a></li><li><a class="tocitem" href="#non-standard-string-literals"><span>非標準文字列リテラル</span></a></li><li><a class="tocitem" href="#Regular-Expressions"><span>正規表現</span></a></li><li><a class="tocitem" href="#man-byte-array-literals"><span>バイト列リテラル</span></a></li><li><a class="tocitem" href="#man-version-number-literals"><span>バージョン番号リテラル</span></a></li><li><a class="tocitem" href="#man-raw-string-literals"><span>Raw 文字列リテラル</span></a></li></ul></li><li><a class="tocitem" href="functions.html">Functions</a></li><li><a class="tocitem" href="control-flow.html">Control Flow</a></li><li><a class="tocitem" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="types.html">型</a></li><li><a class="tocitem" href="methods.html">Methods</a></li><li><a class="tocitem" href="constructors.html">Constructors</a></li><li><a class="tocitem" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li><a class="tocitem" href="modules.html">Modules</a></li><li><a class="tocitem" href="documentation.html">Documentation</a></li><li><a class="tocitem" href="metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="missing.html">Missing Values</a></li><li><a class="tocitem" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="parallel-computing.html">並列計算</a></li><li><a class="tocitem" href="asynchronous-programming.html">非同期プログラミング</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="distributed-computing.html">複数プロセス処理と分散計算</a></li><li><a class="tocitem" href="running-external-programs.html">外部プログラムの実行</a></li><li><a class="tocitem" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="handling-operating-system-variation.html">OSの違いへの対応</a></li><li><a class="tocitem" href="environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="code-loading.html">コードの読み込み</a></li><li><a class="tocitem" href="profile.html">プロファイリング</a></li><li><a class="tocitem" href="stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="performance-tips.html">パフォーマンスのヒント</a></li><li><a class="tocitem" href="workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="style-guide.html">Style Guide</a></li><li><a class="tocitem" href="faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="unicode-input.html">Unicode Input</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="strings.html">文字列</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="strings.html">文字列</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fms-lab/julia-doc-ja/blob/main/doc/src/manual/strings.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-strings"><a class="docs-heading-anchor" href="#man-strings">文字列</a><a id="man-strings-1"></a><a class="docs-heading-anchor-permalink" href="#man-strings" title="Permalink"></a></h1><p>文字列とは有限の文字列を意味します．当然ながら，ここで問題になるのは「文字とは何か」ということです．英語圏の人がよく知っている文字は，アルファベットの「A」「B」「C」などのほか，数字や一般的な句読点などであり，これらの文字は<a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> 規格による 0 ～ 127 の整数値への写像に合わせて規格化されています．確かに，ASCII 文字にアクセントなどの修飾を加えたものやキリル文字やギリシャ文字など英語に関連する script，アラビア語，中国語，ヘブライ語，ヒンディー語，日本語，韓国語などの ASCII や英語とは全く関係のない script など，英語以外の言語で使われている文字は他にもたくさんあります．<a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> 規格は&#39;文字とは何か&#39;という複雑な問題に取り組んでおり，この問題を扱う決定的な規格として一般に受け入れられています．必要に応じて，これらの複雑さを完全に無視して ASCII 文字だけが存在すると考えることもできますし，非 ASCII テキストを扱う際に遭遇する可能性のある文字やエンコーディングを処理できるコードを書くこともできます．Julia ではプレーンな ASCII テキストをシンプルかつ効率的に扱うことができ，また Unicode の取り扱いも可能な限りシンプルかつ効率的です．特に，C スタイルの文字列コードを書いて ASCII 文字列を処理すると性能面でもセマンティクス面でも期待通りに動作します．そのようなコードは，非 ASCII テキストに遭遇した場合，誤った結果を黙って渡されるのではなく，明確なエラーメッセージを表示して潔く失敗するようになっています．このような場合には，非 ASCII データを扱うようにコードを修正することが容易にできます．</p><p>Julia の文字列には，注目すべきハイレベルな特徴がいくつかあります:</p><ul><li>Julia で文字列（および文字列リテラル）に使われる組み込みの具体的な型は，<a href="../base/strings.html#Core.String-Tuple{AbstractString}"><code>String</code></a>です．これは，<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> エンコーディングによる<a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> 文字の全範囲をサポートしています(他の Unicode エンコーディングとの間で変換するための<a href="../base/strings.html#Base.transcode"><code>transcode</code></a>関数が提供されています)．</li><li>すべての文字列型は抽象型である <code>AbstractString</code> のサブタイプであり，外部パッケージではさらに <code>AbstractString</code> サブタイプが定義されています (他のエンコーディング用など)．関数で文字列の引数を取る場合，任意の文字列型を受け付けるためにその型を <code>AbstractString</code> と宣言する必要があります．</li><li>C 言語や Java のように，多くの動的型付け言語とは違い，Julia は単一の文字を表す<a href="../base/strings.html#Core.AbstractChar"><code>AbstractChar</code></a>というファーストクラスの型があります．<code>AbstractChar</code>の組み込みのサブタイプである <a href="../base/strings.html#Core.Char"><code>Char</code></a> は任意の Unicode 文字を表すことのできる 32-bit のプリミティブな型です(UTF-8 エンコーディングに基づいています)．</li><li>Java のように文字列はイミュータブルです． <code>AbstractString</code> 型のオブジェクトは変更不可能です．異なる文字列の値を生成するには他の文字列から新たに生成します．</li><li>概念的に言えば，文字列はインデックスから文字への <em>部分写像</em> です．即ちインデックスの値によっては，文字の値が返されず，例外が発生してしまいます．このためエンコード表現のバイトインデックスも利用でき，効率的な文字列のインデックス呼び出しが可能になります． 文字によるインデックスだと，ユニコード文字列はエンコーディングの変数の幅が変わるので，効率的かつ単純とはならないのです．</li></ul><h2 id="man-characters"><a class="docs-heading-anchor" href="#man-characters">文字</a><a id="man-characters-1"></a><a class="docs-heading-anchor-permalink" href="#man-characters" title="Permalink"></a></h2><p><code>Char</code>は１つの文字を表します．これは，特別なリテラル表現と適切な算術動作を持つ 32 ビットのプリミティブ型であり，<a href="https://en.wikipedia.org/wiki/Code_point">Unicode code point</a> を表す数値に変換することができます（Julia のパッケージでは他の <a href="https://en.wikipedia.org/wiki/Character_encoding">テキストエンコーディング</a> に対する操作を最適化するために<code>AbstractChar</code>などの他のサブタイプを定義することができます)． 以下は，<code>Char</code> の値がどのようなものかを示しています．</p><p>入力と表示:</p><pre><code class="language-julia-repl">julia&gt; &#39;x&#39;
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; typeof(ans)
Char</code></pre><p><code>Char</code>は整数値に容易に変換することができます:</p><pre><code class="language-julia-repl">julia&gt; Int(&#39;x&#39;)
120

julia&gt; typeof(ans)
Int64</code></pre><p>32-bit アーキテクチャでは<a href="../base/base.html#Core.typeof"><code>typeof(ans)</code></a>は<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a>になります．整数値を<code>Char</code>に戻すことも容易です:</p><pre><code class="language-julia-repl">julia&gt; Char(120)
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)</code></pre><p>パフォーマンスのために，任意の整数値が Unicode の符号位置というわけではありませんが，<code>Char</code>変換では文字の値が有効であるかはチェックしません．変換された値が有効な符号位置であるかチェックしたい場合は<a href="../base/strings.html#Base.isvalid-Tuple{Any}"><code>isvalid</code></a>関数を使用します:</p><pre><code class="language-julia-repl">julia&gt; Char(0x110000)
&#39;\U110000&#39;: Unicode U+110000 (category In: Invalid, too high)

julia&gt; isvalid(Char, 0x110000)
false</code></pre><p>この記事を書いている時点で，有効な Unicode 符号位置は，<code>U+0000</code>から<code>U+D7FF</code> および<code>U+E000</code>から<code>U+10FFFF</code>です．これらの符号位置全てに明瞭な意味が与えられたわけではなく，またそれらをアプリケーションが必ずしも解釈できるわけでもありません．しかし，これらの値は全て有効な Unicode 文字であると考えられます．</p><p>任意の Unicode 文字を一重引用符で囲んで入力するには，<code>\u</code>に続けて 4 桁までの 16 進数を入力するか，<code>\U</code>に続けて 8 桁までの 16 進数を入力します（最長の有効値は 6 桁まで）:</p><pre><code class="language-julia-repl">julia&gt; &#39;\u0&#39;
&#39;\0&#39;: ASCII/Unicode U+0000 (category Cc: Other, control)

julia&gt; &#39;\u78&#39;
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &#39;\u2200&#39;
&#39;∀&#39;: Unicode U+2200 (category Sm: Symbol, math)

julia&gt; &#39;\U10ffff&#39;
&#39;\U10ffff&#39;: Unicode U+10FFFF (category Cn: Other, not assigned)</code></pre><p>Julia はシステムのロケールと言語設定を用いてどの文字がそのまま表示可能で，どの文字が一般的なエスケープされた<code>\u</code>や<code>\U</code>を用いた入力形式を用いなければならないかを決定します． それに加え，全ての<a href="https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes">C の従来のエスケープされた入力フォーム</a>も使用することができます．：</p><pre><code class="language-julia-repl">julia&gt; Int(&#39;\0&#39;)
0

julia&gt; Int(&#39;\t&#39;)
9

julia&gt; Int(&#39;\n&#39;)
10

julia&gt; Int(&#39;\e&#39;)
27

julia&gt; Int(&#39;\x7f&#39;)
127

julia&gt; Int(&#39;\177&#39;)
127</code></pre><p><code>Char</code>の値で比較や限られた範囲の算術演算ができます:</p><pre><code class="language-julia-repl">julia&gt; &#39;A&#39; &lt; &#39;a&#39;
true

julia&gt; &#39;A&#39; &lt;= &#39;a&#39; &lt;= &#39;Z&#39;
false

julia&gt; &#39;A&#39; &lt;= &#39;X&#39; &lt;= &#39;Z&#39;
true

julia&gt; &#39;x&#39; - &#39;a&#39;
23

julia&gt; &#39;A&#39; + 1
&#39;B&#39;: ASCII/Unicode U+0042 (category Lu: Letter, uppercase)</code></pre><h2 id="String-Basics"><a class="docs-heading-anchor" href="#String-Basics">文字列の基本</a><a id="String-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#String-Basics" title="Permalink"></a></h2><p>文字列リテラルはタブルクォートやトリプルクォートで区切られます:</p><pre><code class="language-julia-repl">julia&gt; str = &quot;Hello, world.\n&quot;
&quot;Hello, world.\n&quot;

julia&gt; &quot;&quot;&quot;Contains &quot;quote&quot; characters&quot;&quot;&quot;
&quot;Contains \&quot;quote\&quot; characters&quot;</code></pre><p>文字列から 1 文字を取り出したい場合はインデックスで取り出せます．</p><pre><code class="language-julia-repl">julia&gt; str[begin]
&#39;H&#39;: ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[1]
&#39;H&#39;: ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[6]
&#39;,&#39;: ASCII/Unicode U+002C (category Po: Punctuation, other)

julia&gt; str[end]
&#39;\n&#39;: ASCII/Unicode U+000A (category Cc: Other, control)</code></pre><p>文字列を含む多くの Julia のオブジェクトは整数でインデックスをつけることができます．最初の要素(文字列の最初の文字)のインデックスは<a href="../base/collections.html#Base.firstindex"><code>firstindex(str)</code></a>で最後の要素(文字)のインデックスは<a href="../base/collections.html#Base.lastindex"><code>lastindex(str)</code></a>で返されます．キーワード <code>begin</code>と<code>end</code>は，インデックス操作の中で，与えられた次元に沿ったそれぞれの最初と最後のインデックスを表す略語として使用できます．文字列インデックスのような Julia におけるほとんどのインデックスは 1 から始まり，<code>firstindex</code>はどの<code>AbscractString</code>に対しても常に<code>1</code>を返します．しかしながら，後述するように，一般的には<code>lastindex(str)</code>は文字列の<code>length(str)</code>とは違うものです．なぜなら，Unicode 文字は複数の「符号」を占めることがあるからです．</p><p><a href="../base/base.html#end"><code>end</code></a>では通常の値と同じように算術演算やその他の操作を行うことができます:</p><pre><code class="language-julia-repl">julia&gt; str[end-1]
&#39;.&#39;: ASCII/Unicode U+002E (category Po: Punctuation, other)

julia&gt; str[end÷2]
&#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p>インデックスが <code>begin</code> (<code>1</code>) より小さいか，<code>end</code> より大きいと，エラーになります:</p><pre><code class="language-julia-repl">julia&gt; str[begin-1]
ERROR: BoundsError: attempt to access String
  at index [0]
[...]

julia&gt; str[end+1]
ERROR: BoundsError: attempt to access String
  at index [15]
[...]</code></pre><p>レンジインデックスを用いて部分文字列を取り出すことができます:</p><pre><code class="language-julia-repl">julia&gt; str[4:9]
&quot;lo, wo&quot;</code></pre><p><code>str[k]</code> と <code>str[k:k]</code> は同じ結果にならないことに注意してください:</p><pre><code class="language-julia-repl">julia&gt; str[6]
&#39;,&#39;: ASCII/Unicode U+002C (category Po: Punctuation, other)

julia&gt; str[6:6]
&quot;,&quot;</code></pre><p>前者は <code>Char</code> 型の 1 文字の値で，後者は 1 文字しか含まない文字列の値です． 後者は，たまたま 1 文字しか含まれていない文字列値です．Julia ではこれらは全く異なるものです．</p><p>範囲指定では下の文字列の選択された部分をコピーします．また，<a href="../base/strings.html#Base.SubString"><code>SubString</code></a>型を使って文字列へのビューを作成することもできます．</p><p>例:</p><pre><code class="language-julia-repl">julia&gt; str = &quot;long string&quot;
&quot;long string&quot;

julia&gt; substr = SubString(str, 1, 4)
&quot;long&quot;

julia&gt; typeof(substr)
SubString{String}</code></pre><p><a href="../base/strings.html#Base.chop"><code>chop</code></a>，<a href="../base/strings.html#Base.chomp"><code>chomp</code></a>，<a href="../base/strings.html#Base.strip"><code>strip</code></a>のようないくつかの標準的な関数は，<a href="../base/strings.html#Base.SubString"><code>SubString</code></a>を返します．</p><h2 id="Unicode-and-UTF-8"><a class="docs-heading-anchor" href="#Unicode-and-UTF-8">Unicode と UTF-8</a><a id="Unicode-and-UTF-8-1"></a><a class="docs-heading-anchor-permalink" href="#Unicode-and-UTF-8" title="Permalink"></a></h2><p>Julia は Unicode 文字とその文字列に完全に対応しています．<a href="strings.html#man-characters"><code>上述</code></a>のように，文字リテラルでは，Unicode の符号位置は，Unicode の<code>\u</code>と<code>\U</code>のエスケープシーケンスや，C 標準のエスケープシーケンスを使って表現することができます．これらは，文字列リテラルを記述する際にも同様に使用できます:</p><pre><code class="language-julia-repl">julia&gt; s = &quot;\u2200 x \u2203 y&quot;
&quot;∀ x ∃ y&quot;</code></pre><p>これらの Unicode 文字がエスケープされて表示されるか，特殊文字として表示されるかは，ターミナルのロケール設定と Unicode の対応状況に依存します．文字列リテラルのエンコードには UTF-8 エンコーディングを使用してエンコードされます．UTF-8 は可変幅のエンコーディングなので，つまりすべての文字が同じバイト数（「符号」）でエンコードされるわけではありません．UTF-8 では，ASCII 文字，つまり符号位置が 0x80（128）未満の文字は，ASCII と同じように 1 バイトでエンコードされますが，符号位置が 0x80 以上の文字は 1 文字あたり最大 4 バイトまでの複数バイトでエンコードされます.</p><p>Julia の文字列インデックスは，任意の文字（符号位置）をエンコードするための固定幅の構成要素である符号（＝ UTF-8 ではバイト）を指します．つまり，<code>String</code>へのすべてのインデックスが，必ずしも文字に対して有効なインデックスではないということです．このような無効なバイトインデックスで文字列を入力した場合，エラーが発生します:</p><pre><code class="language-julia-repl">julia&gt; s[1]
&#39;∀&#39;: Unicode U+2200 (category Sm: Symbol, math)

julia&gt; s[2]
ERROR: StringIndexError(&quot;∀ x ∃ y&quot;, 2)
[...]

julia&gt; s[3]
ERROR: StringIndexError(&quot;∀ x ∃ y&quot;, 3)
Stacktrace:
[...]

julia&gt; s[4]
&#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p>この場合，文字<code>∀</code>は 3 バイト文字なので，インデックス 2 と 3 は無効で，次の文字のインデックスは 4 となります．この次の有効なインデックスは<a href="../base/strings.html#Base.nextind"><code>nextind(s,1)</code></a>で計算でき，その次のインデックスは<code>nextind(s,4)</code>となります．</p><p><code>end</code>は常にコレクションの最後の有効なインデックスなので，最後から 2 番目の文字がマルチバイトの場合，<code>end-1</code>は無効なバイトインデックスを参照します．</p><pre><code class="language-julia-repl">julia&gt; s[end-1]
&#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)

julia&gt; s[end-2]
ERROR: StringIndexError(&quot;∀ x ∃ y&quot;, 9)
Stacktrace:
[...]

julia&gt; s[prevind(s, end, 2)]
&#39;∃&#39;: Unicode U+2203 (category Sm: Symbol, math)</code></pre><p>最初のケースは，最後の文字 <code>y</code> とスペースが 1 バイト文字であるので動作するのに対し，インデックス<code>end-2</code> は <code>∃</code> のマルチバイト表現の中央にインデックスを置くので，動作しません． この場合の正しい方法は，<code>prevind(s, lastindex(s), 2)</code>を使うか，<code>s</code>へのインデックスにその値を使うのであれば<code>s[prevind(s, end, 2)]</code>と書き，<code>end</code>は<code>lastindex(s)</code>に展開されます．</p><p>レンジインデックスを使用した部分文字列の抽出でも有効なバイトインデックスは必要であり，そうでない場合はエラーが発生します:</p><pre><code class="language-julia-repl">julia&gt; s[1:1]
&quot;∀&quot;

julia&gt; s[1:2]
ERROR: StringIndexError(&quot;∀ x ∃ y&quot;, 2)
Stacktrace:
[...]

julia&gt; s[1:4]
&quot;∀ &quot;</code></pre><p>可変長エンコーディングのため，（<a href="../base/arrays.html#Base.length-Tuple{AbstractArray}"><code>length(s)</code></a>で与えられる）文字列の文字数は，最後のインデックスと同じとは限りません． 1 から<a href="../base/collections.html#Base.lastindex"><code>lastindex(s)</code></a>までのインデックスを反復して<code>s</code>の文字を参照すると，エラーが発生しなかったときに返される文字列は文字列<code>s</code>を構成する文字列となります．このように文字列の各文字にはそれぞれインデックスが必要なので，<code>length(s) &lt;= lastindex(s)</code>という恒等式が成り立ちます．以下は，<code>s</code>の文字を反復する非効率的で冗長な方法です．</p><pre><code class="language-julia-repl">julia&gt; for i = firstindex(s):lastindex(s)
           try
               println(s[i])
           catch
               # ignore the index error
           end
       end
∀

x

∃

y</code></pre><p>空白行は実際にはスペースが入っています．幸いなことに，文字列内の文字を反復処理する際には，上記のような厄介なイディオムは必要ありません．文字列を反復可能なオブジェクトとして使用するだけで，例外処理は必要ありません:</p><pre><code class="language-julia-repl">julia&gt; for c in s
           println(c)
       end
∀

x

∃

y</code></pre><p>文字列の有効なインデックスを取得する必要がある場合には，前述のように，<a href="../base/strings.html#Base.nextind"><code>nextind</code></a> および <a href="../base/strings.html#Base.prevind"><code>prevind</code></a> 関数を使って，有効な次/前のインデックスにインクリメント/デクリメントすることができます．また，<a href="../base/arrays.html#Base.eachindex"><code>eachindex</code></a>関数を使って，有効な文字列インデックスを繰り返し処理することもできます:</p><pre><code class="language-julia-repl">julia&gt; collect(eachindex(s))
7-element Array{Int64,1}:
  1
  4
  5
  6
  7
 10
 11</code></pre><p>エンコーディングの未加工の符号（UTF-8 の場合はバイト）にアクセスするには，<a href="../base/strings.html#Base.codeunit"><code>codeunit(s,i)</code></a>関数を使います．ここで，インデックス<code>i</code>は<code>1</code>から<a href="../base/strings.html#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits(s)</code></a>まで連続しています．<a href="../base/strings.html#Base.codeunits"><code>codeunits(s)</code></a>関数は<code>AbstractVector{UInt8}</code>というラッパーを返すので，これらの未加工の符号（バイト）を配列として利用することができます．</p><p>Julia の文字列には，無効な UTF-8 符号列が含まれることがあります．この規約により，任意のバイト列を <code>String</code> として扱うことができます．このような状況では，符号列を左から右に解析する際に，文字は以下のビットパターン（各 <code>x</code> は <code>0</code> または <code>1</code>）のいずれかの開始に一致する，最長の 8 ビットの符号列によって形成されるというルールがあります．</p><ul><li><code>0xxxxxxx</code>;</li><li><code>110xxxxx</code> <code>10xxxxxx</code>;</li><li><code>1110xxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</li><li><code>11110xxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code> <code>10xxxxxx</code>;</li><li><code>10xxxxxx</code>;</li><li><code>11111xxx</code>.</li></ul><p>特に，冗長すぎたり値が大きすぎたりする符号列とその接頭辞は，複数の無効な文字ではなく，単一の無効な文字として扱われます．このルールは，例を挙げて説明するのが一番わかりやすいでしょう．</p><pre><code class="language-julia-repl">julia&gt; s = &quot;\xc0\xa0\xe2\x88\xe2|&quot;
&quot;\xc0\xa0\xe2\x88\xe2|&quot;

julia&gt; foreach(display, s)
&#39;\xc0\xa0&#39;: [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)
&#39;\xe2\x88&#39;: Malformed UTF-8 (category Ma: Malformed, bad data)
&#39;\xe2&#39;: Malformed UTF-8 (category Ma: Malformed, bad data)
&#39;|&#39;: ASCII/Unicode U+007C (category Sm: Symbol, math)

julia&gt; isvalid.(collect(s))
4-element BitArray{1}:
 0
 0
 0
 1

julia&gt; s2 = &quot;\xf7\xbf\xbf\xbf&quot;
&quot;\U1fffff&quot;

julia&gt; foreach(display, s2)
&#39;\U1fffff&#39;: Unicode U+1FFFFF (category In: Invalid, too high)</code></pre><p>文字列 <code>s</code> の最初の 2 つの符号が，空白文字の冗長なエンコーディングを形成していることがわかります．これは無効ですが，文字列では 1 つの文字として受け入れられます．次の 2 つの符号は，3 バイトの UTF-8 の列の有効な開始を形成します．しかし，5 番目の符号<code>\xe2</code>は有効な値ではありません．したがって，3 番目と 4 番目の符号もこの文字列では不正な文字として解釈されます．同様に，5 番目の符号は<code>｜</code>が有効な継続部分ではないため，不正な文字を形成します．最後に，文字列 <code>s2</code> には 大きすぎる符号位置が 1 つ含まれています．</p><p>Julia はデフォルトでは UTF-8 エンコーディングを使用しますが，新しいエンコーディングのサポートはパッケージによって追加することができます．例えば，<a href="https://github.com/JuliaStrings/LegacyStrings.jl">LegacyStrings.jl</a>パッケージでは，<code>UTF16String</code>型と<code>UTF32String</code>型を実装しています．他のエンコーディングやそのサポートの実装方法についての詳しい説明はこのドキュメントの範囲外となります．また UTF-8 エンコーディングの問題については，以下の<a href="strings.html#man-byte-array-literals"><code>byte array literals</code></a>の節を参照してください．様々な UTF-xx エンコーディングの間でデータを変換するために，<a href="../base/strings.html#Base.transcode"><code>transcode</code></a> 関数が提供されています．これは主に外部のデータやライブラリを扱うためのものです．</p><h2 id="man-concatenation"><a class="docs-heading-anchor" href="#man-concatenation">連結</a><a id="man-concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#man-concatenation" title="Permalink"></a></h2><p>最も一般的で便利な文字列操作の一つが連結です:</p><pre><code class="language-julia-repl">julia&gt; greet = &quot;Hello&quot;
&quot;Hello&quot;

julia&gt; whom = &quot;world&quot;
&quot;world&quot;

julia&gt; string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)
&quot;Hello, world.\n&quot;</code></pre><p>無効な UTF-8 文字列の連結など，潜在的に危険な状況に注意することが重要です．結果として得られる文字列には，入力文字列とは異なる文字が含まれている可能性があり，その文字数は，連結された文字列の文字数の合計よりも少ない可能性があります．</p><p>例:</p><pre><code class="language-julia-repl">julia&gt; a, b = &quot;\xe2\x88&quot;, &quot;\x80&quot;
(&quot;\xe2\x88&quot;, &quot;\x80&quot;)

julia&gt; c = a*b
&quot;∀&quot;

julia&gt; collect.([a, b, c])
3-element Array{Array{Char,1},1}:
 [&#39;\xe2\x88&#39;]
 [&#39;\x80&#39;]
 [&#39;∀&#39;]

julia&gt; length.([a, b, c])
3-element Array{Int64,1}:
 1
 1
 1</code></pre><p>この状況は，無効な UTF-8 文字列に対してのみ発生します．有効な UTF-8 文字列の場合，連結は文字列内のすべての文字と文字列長の加法性を保持します．</p><p>また，Julia には文字列連結のための<a href="../base/math.html#Base.:*-Tuple{Any,Vararg{Any,N} where N}"><code>*</code></a>が用意されています:</p><pre><code class="language-julia-repl">julia&gt; greet * &quot;, &quot; * whom * &quot;.\n&quot;
&quot;Hello, world.\n&quot;</code></pre><p>一方，文字列の連結に <code>+</code> を提供している言語のユーザーにとっては，<code>*</code> は意外な選択に思えるかもしれませんが，<code>*</code> の使用は，数学，特に抽象代数では前例があります．数学では，<code>+</code>は通常，被演算子の順序が問題にならない <em>可換</em> の演算を表します．この例として行列の加算を考えると，同じ形の行列 <code>A</code> と <code>B</code> に対して<code>A + B == B + A</code> となります．対照的に，<code>*</code> は一般的に <em>非可換</em> 演算を表し，演算子の順序が重要になります．この例として行列の乗算を考えると，一般的には <code>A * B != B * A</code> となります．行列の乗算と同様に文字列の連結も <em>非可換</em> です．例えば，<code>greet * whom != whom * greet</code>となります．このように， 中置記法の文字列連結演算子としては <code>*</code> がより自然な選択であり，一般的な数学的使用と一致しています．</p><p>より正確には，すべての有限長の文字列 <em>S</em> と文字列連結演算子<code>*</code>の集合は，<a href="https://en.wikipedia.org/wiki/Free_monoid">自由モノイド</a> (<em>S</em>, <code>*</code>)を形成します．この集合の恒等要素は空文字列 <code>&quot;&quot;</code> です．自由モノイドが可換でない場合，その演算は通常 <code>+</code> ではなく<code>cdot</code>, <code>*</code>, または同様の記号で表されます．</p><h2 id="string-interpolation"><a class="docs-heading-anchor" href="#string-interpolation">文字列補間</a><a id="string-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#string-interpolation" title="Permalink"></a></h2><p>連結で文字列を構築するのは少々面倒な作業です．そこで，<a href="../base/strings.html#Base.string"><code>string</code></a>のくどい呼び出しや繰り返しの乗算を減らすために，Julia では Perl のように，<code>$</code>を用いて文字列リテラルに補間することができます:</p><pre><code class="language-julia-repl">julia&gt; &quot;$greet, $whom.\n&quot;
&quot;Hello, world.\n&quot;</code></pre><p>こちらはより読みやすく便利で，上記の文字列連結と同値です．システムは，この見かけ上の単一の文字列リテラルを呼び出し<code>string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)</code>に書き換えます．</p><p><code>$</code>の後の最も短い完全な式が，文字列に値を補うべき式とみなされます．このように，括弧を使えば，どんな式でも文字列に補間することができます:</p><pre><code class="language-julia-repl">julia&gt; &quot;1 + 2 = $(1 + 2)&quot;
&quot;1 + 2 = 3&quot;</code></pre><p>連結や文字列補間では，オブジェクトを文字列に変換するために <a href="../base/strings.html#Base.string"><code>string</code></a> を呼び出します．しかし，<code>string</code>は実際には <a href="../base/io-network.html#Base.print"><code>print</code></a> の出力を返すだけなので，新しい型では<code>string</code>の代わりに <a href="../base/io-network.html#Base.print"><code>print</code></a> や <a href="../base/io-network.html#Base.show-Tuple{IO,Any}"><code>show</code></a> のメソッドを追加する必要があります．</p><p>多くの<code>AbstractString</code>ではないオブジェクトは，リテラル式として入力された様式に近い形で文字列に変換されます．</p><pre><code class="language-julia-repl">julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; &quot;v: $v&quot;
&quot;v: [1, 2, 3]&quot;</code></pre><p><a href="../base/strings.html#Base.string"><code>string</code></a>は<code>AbstractString</code>や<code>AbstractChar</code>の値と恒等であり，これらは引用符やエスケープされずにそのまま文字列に補間されます．</p><pre><code class="language-julia-repl">julia&gt; c = &#39;x&#39;
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &quot;hi, $c&quot;
&quot;hi, x&quot;</code></pre><p>リテラル <code>$</code> を文字列リテラルに含めるには，バックスラッシュでエスケープします:</p><pre><code class="language-julia-repl">julia&gt; print(&quot;I have \$100 in my account.\n&quot;)
I have $100 in my account.</code></pre><h2 id="Triple-Quoted-String-Literals"><a class="docs-heading-anchor" href="#Triple-Quoted-String-Literals">トリプルクォーテーション付きの文字列リテラル</a><a id="Triple-Quoted-String-Literals-1"></a><a class="docs-heading-anchor-permalink" href="#Triple-Quoted-String-Literals" title="Permalink"></a></h2><p>トリプルクォーテーション（<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>）を使った文字列には，長いテキストブロックを作成するのに便利で特別な動作があります．</p><p>まず，トリプルクォーテーションで囲まれた文字列はインデントが少ない行のレベルを基準として，インデントが除去(ディデンテーション)されます．これは，コードの中でインデントを含んだ文字列を定義するのに便利です．例えば，以下のようになります:</p><pre><code class="language-julia-repl">julia&gt; str = &quot;&quot;&quot;
           Hello,
           world.
         &quot;&quot;&quot;
&quot;  Hello,\n  world.\n&quot;</code></pre><p>この場合は閉じる側の<code>&quot;&quot;&quot;</code>の直前の(空)行がインデントレベルとして設定されます．</p><p>ディデンテーションレベルは，冒頭の <code>&quot;&quot;&quot;</code> に続く行と，スペースまたはタブだけを含む行を除いた，すべての行のうち，最も長い先頭のスペースまたはタブ数によって決められます（最後の <code>&quot;&quot;&quot;</code> を含む行は常に含まれます）．続いて，冒頭の <code>&quot;&quot;&quot;</code> に続く行を除いたすべての行について，各行先頭の空白やタブが削除されます（スペースとタブだけを含む行を含む）．</p><p>例:</p><pre><code class="language-julia-repl">julia&gt; &quot;&quot;&quot;    This
         is
           a test&quot;&quot;&quot;
&quot;    This\nis\n  a test&quot;</code></pre><p>次に，冒頭の <code>&quot;&quot;&quot;</code> の後に改行がある場合は結果の文字列から改行が取り除かれます．</p><pre><code class="language-julia">&quot;&quot;&quot;hello&quot;&quot;&quot;</code></pre><p>これは以下と等価です．</p><pre><code class="language-julia">&quot;&quot;&quot;
hello&quot;&quot;&quot;</code></pre><p>しかし</p><pre><code class="language-julia">&quot;&quot;&quot;

hello&quot;&quot;&quot;</code></pre><p>は先頭に改行リテラルを含みます．</p><p>改行の除去は，ディテンデーションの後に行われます．例えば以下のようになります:</p><pre><code class="language-julia-repl">julia&gt; &quot;&quot;&quot;
         Hello,
         world.&quot;&quot;&quot;
&quot;Hello,\nworld.&quot;</code></pre><p>末尾のホワイトスペースはそのまま残されます.</p><p>トリプルクォーテーションで囲まれた文字列リテラルには，エスケープせずに <code>&quot;</code> 文字を含めることができます．</p><p>リテラル文字列の改行はリテラルがシングルクオーテーション，トリプルクオーテーションどちらで囲まれていても返り値の改行部分は改行（LF）文字<code>\n</code>が入ります．これはエディタが CR 文字や CRLF の組み合わせで行を終わらせている場合でも同様です．文字列に CR 文字を含めるには，明示的なエスケープを使用します，例えば/リテラル文字列 <code>&quot;a CRLF line ending\r\n&quot;</code> を入力します．</p><h2 id="Common-Operations"><a class="docs-heading-anchor" href="#Common-Operations">よくある操作</a><a id="Common-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Operations" title="Permalink"></a></h2><p>標準的な比較演算子を使って，文字列を辞書的に比較することができます．</p><pre><code class="language-julia-repl">julia&gt; &quot;abracadabra&quot; &lt; &quot;xylophone&quot;
true

julia&gt; &quot;abracadabra&quot; == &quot;xylophone&quot;
false

julia&gt; &quot;Hello, world.&quot; != &quot;Goodbye, world.&quot;
true

julia&gt; &quot;1 + 2 = 3&quot; == &quot;1 + 2 = $(1 + 2)&quot;
true</code></pre><p><a href="../base/arrays.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>および<a href="../base/arrays.html#Base.findlast-Tuple{Any}"><code>findlast</code></a>関数を使って，特定の文字のインデックスを検索することができます．</p><pre><code class="language-julia-repl">julia&gt; findfirst(isequal(&#39;o&#39;), &quot;xylophone&quot;)
4

julia&gt; findlast(isequal(&#39;o&#39;), &quot;xylophone&quot;)
7

julia&gt; findfirst(isequal(&#39;z&#39;), &quot;xylophone&quot;)</code></pre><p>関数<a href="../base/arrays.html#Base.findnext-Tuple{Any,Integer}"><code>findnext</code></a>や<a href="../base/arrays.html#Base.findprev-Tuple{Any,Integer}"><code>findprev</code></a>を使えば，指定したオフセットで文字の検索を開始することができます．</p><pre><code class="language-julia-repl">julia&gt; findnext(isequal(&#39;o&#39;), &quot;xylophone&quot;, 1)
4

julia&gt; findnext(isequal(&#39;o&#39;), &quot;xylophone&quot;, 5)
7

julia&gt; findprev(isequal(&#39;o&#39;), &quot;xylophone&quot;, 5)
4

julia&gt; findnext(isequal(&#39;o&#39;), &quot;xylophone&quot;, 8)</code></pre><p>文字列の中に部分文字列があるかどうかを調べるには<a href="../base/strings.html#Base.occursin"><code>occursin</code></a>関数を使います．</p><pre><code class="language-julia-repl">julia&gt; occursin(&quot;world&quot;, &quot;Hello, world.&quot;)
true

julia&gt; occursin(&quot;o&quot;, &quot;Xylophon&quot;)
true

julia&gt; occursin(&quot;a&quot;, &quot;Xylophon&quot;)
false

julia&gt; occursin(&#39;o&#39;, &quot;Xylophon&quot;)
true</code></pre><p>最後の例では，<a href="../base/strings.html#Base.occursin"><code>occursin</code></a>が文字リテラルを探すこともできることを示しています．</p><p>他にも便利な文字列関数として<a href="../base/arrays.html#Base.repeat"><code>repeat</code></a>や<a href="../base/strings.html#Base.join"><code>join</code></a>があります．</p><pre><code class="language-julia-repl">julia&gt; repeat(&quot;.:Z:.&quot;, 10)
&quot;.:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.&quot;

julia&gt; join([&quot;apples&quot;, &quot;bananas&quot;, &quot;pineapples&quot;], &quot;, &quot;, &quot; and &quot;)
&quot;apples, bananas and pineapples&quot;</code></pre><p>他にも便利な関数があります:</p><ul><li><a href="../base/collections.html#Base.firstindex"><code>firstindex(str)</code></a>は<code>str</code> へのインデックスに使用できる最小の（バイト）インデックスを返します（文字列の場合は常に 1 ですが，他のコンテナの場合は必ずしもそうではありません）．</li><li><a href="../base/collections.html#Base.lastindex"><code>lastindex(str)</code></a>は，<code>str</code> のインデックスに使用できる最大の（バイト）インデックスを返します．</li><li><a href="../base/arrays.html#Base.length-Tuple{AbstractArray}"><code>length(str)</code></a> は<code>str</code>の文字数です．</li><li><a href="../base/arrays.html#Base.length-Tuple{AbstractArray}"><code>length(str, i, j)</code></a> は<code>str</code> の中の <code>i</code> から <code>j</code> までの有効な文字インデックスの数です．</li><li><a href="../base/strings.html#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits(str)</code></a> は文字列中の<a href="https://en.wikipedia.org/wiki/Character_encoding#Terminology">code units</a>の数です．</li><li><a href="../base/strings.html#Base.codeunit"><code>codeunit(str, i)</code></a> は文字列 <code>str</code> のインデックス <code>i</code> にコードユニットの値を返します．</li><li><a href="../base/strings.html#Base.thisind"><code>thisind(str, i)</code></a> は文字列に任意のインデックスを与えると，そのインデックスが指し示す文字の最初のインデックスを返します．</li><li><a href="../base/strings.html#Base.nextind"><code>nextind(str, i, n=1)</code></a> は添字 <code>i</code> から始まる <code>n</code> 番目の文字の先頭を見つけます．</li><li><a href="../base/strings.html#Base.prevind"><code>prevind(str, i, n=1)</code></a> は添字 <code>i</code> より前の <code>n</code> 番目の文字の始まりを見つけます．</li></ul><h2 id="non-standard-string-literals"><a class="docs-heading-anchor" href="#non-standard-string-literals">非標準文字列リテラル</a><a id="non-standard-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#non-standard-string-literals" title="Permalink"></a></h2><p>文字列を作成したり文字列セマンティクスを使用したりしたいが，標準的な文字列構築の動作が必要とされるものとは全く異なる場合があります．このような状況のために，Julia は<a href="strings.html#non-standard-string-literals"><code>非標準文字列リテラル</code></a>を提供しています． 非標準文字列リテラルは通常のダブルクオーテーションで囲まれた文字列リテラルのように見えますが，識別子として接頭辞がつけられ，通常の文字列リテラルのようには動作しません．具体的には後述の正規表現，バイト配列リテラル，バージョン番号リテラルなどがなどが挙げられます．その他の例 は<a href="metaprogramming.html#Metaprogramming"><code>メタプログラミング</code></a>の項を参照してください．</p><h2 id="Regular-Expressions"><a class="docs-heading-anchor" href="#Regular-Expressions">正規表現</a><a id="Regular-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-Expressions" title="Permalink"></a></h2><p>Julia は，<a href="http://www.pcre.org/">PCRE</a>ライブラリが提供する Perl 互換の正規表現(regexes)を備えています（構文の説明は<a href="http://www.pcre.org/current/doc/html/pcre2syntax.html">こちら</a>にあります）．正規表現は文字列と 2 つの点で関連しています．まず明らかな関連性として，正規表現が文字列の正規パターンを見つけるために使用される点が挙げられます．もう一つの関連性は，正規表現はそれ自体が文字列として入力され，文字列内のパターンを効率的に検索するために使用される状態機械(ステートマシン)に解析されるということです．Julia では，正規表現は <code>r</code>で始まる様々な識別子を前置した非標準の文字列リテラルを使って入力されます．最も基本的な正規表現リテラルは，オプションを何もつけずに<code>r&quot;...&quot;</code>を使うだけです:</p><pre><code class="language-julia-repl">julia&gt; r&quot;^\s*(?:#|$)&quot;
r&quot;^\s*(?:#|$)&quot;

julia&gt; typeof(ans)
Regex</code></pre><p>正規表現が文字列にマッチするかどうかを調べるには，<a href="../base/strings.html#Base.occursin"><code>occursin</code></a>を使います:</p><pre><code class="language-julia-repl">julia&gt; occursin(r&quot;^\s*(?:#|$)&quot;, &quot;not a comment&quot;)
false

julia&gt; occursin(r&quot;^\s*(?:#|$)&quot;, &quot;# a comment&quot;)
true</code></pre><p>ここで見られるように，<a href="../base/strings.html#Base.occursin"><code>occursin</code></a>は単純に true または false を返し，与えられた正規表現にマッチするものが文字列の中に存在するかどうかを示します．しかし，一般的には文字列がマッチしたかどうかだけでなく，どのようにマッチしたかを知りたい場合があります．このようなマッチに関する情報を取得するには，代わりに <a href="../base/strings.html#Base.match"><code>match</code></a> 関数を使用します:</p><pre><code class="language-julia-repl">julia&gt; match(r&quot;^\s*(?:#|$)&quot;, &quot;not a comment&quot;)

julia&gt; match(r&quot;^\s*(?:#|$)&quot;, &quot;# a comment&quot;)
RegexMatch(&quot;#&quot;)</code></pre><p>正規表現が与えられた文字列にマッチしなかった場合，<a href="../base/strings.html#Base.match"><code>match</code></a>は <a href="../base/constants.html#Core.nothing"><code>nothing</code></a>を返します．これは，対話型プロンプトに何も表示しない特別な値です．何も表示されないだけであり，正常な値であるのでプログラムは正常に動作します．</p><pre><code class="language-julia">m = match(r&quot;^\s*(?:#|$)&quot;, line)
if m === nothing
    println(&quot;not a comment&quot;)
else
    println(&quot;blank or comment&quot;)
end</code></pre><p>正規表現にマッチした場合，<a href="../base/strings.html#Base.match"><code>match</code></a>は <code>RegexMatch</code> オブジェクトを返します．これらのオブジェクトはパターンがマッチした部分文字列やキャプチャされた部分文字列に対して正規表現がどのようにマッチしたかを記録したものです．この例では，マッチした部分文字列のみをキャプチャしていますが，コメントの後の空白でないテキストもキャプチャしたい場合があります． その場合は次のようにします:</p><pre><code class="language-julia-repl">julia&gt; m = match(r&quot;^\s*(?:#\s*(.*?)\s*$|$)&quot;, &quot;# a comment &quot;)
RegexMatch(&quot;# a comment &quot;, 1=&quot;a comment&quot;)</code></pre><p><a href="../base/strings.html#Base.match"><code>match</code></a>を呼び出す際には検索を開始するインデックスを指定できるオプションがあります．</p><p>例:</p><pre><code class="language-julia-repl">julia&gt; m = match(r&quot;[0-9]&quot;,&quot;aaaa1aaaa2aaaa3&quot;,1)
RegexMatch(&quot;1&quot;)

julia&gt; m = match(r&quot;[0-9]&quot;,&quot;aaaa1aaaa2aaaa3&quot;,6)
RegexMatch(&quot;2&quot;)

julia&gt; m = match(r&quot;[0-9]&quot;,&quot;aaaa1aaaa2aaaa3&quot;,11)
RegexMatch(&quot;3&quot;)</code></pre><p><code>RegexMatch</code>オブジェクトからは以下の情報を抽出することができます:</p><ul><li>マッチした部分文字列全体: <code>m.match</code></li><li>キャプチャされた部分文字列が文字列の配列になったもの: <code>m.captures</code></li><li>マッチした文字列の開始位置(オフセット): <code>m.offset</code></li><li>キャプチャされた部分文字列のオフセットをベクトルで表したもの: <code>m.offsets</code></li></ul><p>キャプチャがマッチしない場合，<code>m.captures</code>にはその位置に<code>nothing</code>が含まれ，<code>m.offsets</code>にはゼロのオフセットが含まれます(Julia のインデックスは 1 ベースなので，文字列へのゼロの 文字列へのゼロオフセットは無効です）．以下では，やや作為的な例を 2 つ示します:</p><pre><code class="language-julia-repl">julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;acd&quot;)
RegexMatch(&quot;acd&quot;, 1=&quot;a&quot;, 2=&quot;c&quot;, 3=&quot;d&quot;)

julia&gt; m.match
&quot;acd&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 &quot;c&quot;
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;ad&quot;)
RegexMatch(&quot;ad&quot;, 1=&quot;a&quot;, 2=nothing, 3=&quot;d&quot;)

julia&gt; m.match
&quot;ad&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 nothing
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2</code></pre><p>キャプチャを配列として返すと分割代入を使ってローカル変数にバインドすることができます:</p><pre><code class="language-julia-repl">julia&gt; first, second, third = m.captures; first
&quot;a&quot;</code></pre><p>キャプチャは<code>RegexMatch</code>のインデックス番号か，名前付きキャプチャグループをインデックスすることでアクセスできます:</p><pre><code class="language-julia-repl">julia&gt; m=match(r&quot;(?&lt;hour&gt;\d+):(?&lt;minute&gt;\d+)&quot;,&quot;12:45&quot;)
RegexMatch(&quot;12:45&quot;, hour=&quot;12&quot;, minute=&quot;45&quot;)

julia&gt; m[:minute]
&quot;45&quot;

julia&gt; m[2]
&quot;45&quot;</code></pre><p><a href="../base/collections.html#Base.replace-Tuple{Any,Vararg{Pair,N} where N}"><code>replace</code></a>を使った置換文字列でキャプチャーを参照するには，<code>\n</code>を使って n 番目のキャプチャグループを参照し，置換文字列の前に<code>s</code>を付けます．キャプチャグループ 0 はマッチオブジェクト全体を指します．名前付きキャプチャグループは，置換文字列の中で <code>\g&lt;groupname&gt;</code> を使って参照できます．たとえば，以下のようになります:</p><pre><code class="language-julia-repl">julia&gt; replace(&quot;first second&quot;, r&quot;(\w+) (?&lt;agroup&gt;\w+)&quot; =&gt; s&quot;\g&lt;agroup&gt; \1&quot;)
&quot;second first&quot;</code></pre><p>番号の付いたキャプチャーグループは，曖昧さ回避のために<code>g&lt;n&gt;</code>として参照することもでき，以下のようになります:</p><pre><code class="language-julia-repl">julia&gt; replace(&quot;a&quot;, r&quot;.&quot; =&gt; s&quot;\g&lt;0&gt;1&quot;)
&quot;a1&quot;</code></pre><p>ダブルクォーテーションマークの後のフラグ<code>i</code>，<code>m</code>，<code>s</code>，<code>x</code>の組み合わせによって，正規表現の動作を変更することができます．これらのフラグは，<a href="http://perldoc.perl.org/perlre.html#Modifiers">perlre manpage</a>からの抜粋で説明されているように，Perl におけるフラグと同じ意味を持っています．</p><pre><code class="language-none">i   大文字小文字を区別しないパターンマッチング

    ロケール照合規則が有効な場合，符号位置が255未満の場合は現在のロケールから，
    それ以上の場合はUnicode規則から，ケースマップを取得します．ただし，Unicode規則と
    非Unicode規則の境界（コード番号255/256）を超えるようなマッチは (ords 255/256)
    を超えるマッチは成功しません．

m   文字列を複数行として扱います．つまり，&quot;^&quot;と&quot;$&quot;は文字列の開始または終了にマッチするのではなく
    文字列内の任意の行の開始または終了に一致するように変更します．

s   文字列を一行として扱います．つまり，&quot;.&quot;を任意の文字や通常はマッチしない
    &quot;改行&quot;にもマッチするように変更されます．

    r&quot;&quot;msのようにmとsを一緒に使うと&quot;. “は任意の文字にマッチする一方で，&quot;^&quot; and “$&quot;は
    それぞれ任意の行の開始と終了文字にマッチします．

x   正規表現パーサーは，バックスラッシュでも文字クラスにも含まれないほとんどの空白を無視します．
    これを使うと，正規表現を（少し）読みやすいパーツに分割することができます．
    また，&#39;#&#39;文字は，通常のコードと同様に，コメントを表すメタ文字として扱われます．</code></pre><p>例えば，次の正規表現は 3 つのフラグがすべてオンになっています:</p><pre><code class="language-julia-repl">julia&gt; r&quot;a+.*b+.*?d$&quot;ism
r&quot;a+.*b+.*?d$&quot;ims

julia&gt; match(r&quot;a+.*b+.*?d$&quot;ism, &quot;Goodbye,\nOh, angry,\nBad world\n&quot;)
RegexMatch(&quot;angry,\nBad world&quot;)</code></pre><p><code>r&quot;...&quot;</code> リテラルは，補間やエスケープを行わずに構築されます（ただし，引用符 <code>&quot;</code> はエスケープが必要です）．以下は標準的な文字列リテラルとの違いを示した例です:</p><pre><code class="language-julia-repl">julia&gt; x = 10
10

julia&gt; r&quot;$x&quot;
r&quot;$x&quot;

julia&gt; &quot;$x&quot;
&quot;10&quot;

julia&gt; r&quot;\x&quot;
r&quot;\x&quot;

julia&gt; &quot;\x&quot;
ERROR: syntax: invalid escape sequence</code></pre><p><code>r&quot;&quot;&quot;...&quot;&quot;&quot;</code>のようにトリプルクォーテーションで囲まれた正規表現の文字列もサポートされています(クオーテーションや改行文字を含む正規表現には便利です)．</p><p><code>Regex()</code>コンストラクタを使うと，プログラムで有効な正規表現の文字列を作成することができます．これにより，正規表現文字列を作成する際に文字列変数の内容や他の文字列操作を使用することができます．上記の正規表現コードのいずれも，<code>Regex()</code>の文字列引数の中で使用することができます．以下にその例を示します:</p><pre><code class="language-julia-repl">julia&gt; using Dates

julia&gt; d = Date(1962,7,10)
1962-07-10

julia&gt; regex_d = Regex(&quot;Day &quot; * string(day(d)))
r&quot;Day 10&quot;

julia&gt; match(regex_d, &quot;It happened on Day 10&quot;)
RegexMatch(&quot;Day 10&quot;)

julia&gt; name = &quot;Jon&quot;
&quot;Jon&quot;

julia&gt; regex_name = Regex(&quot;[\&quot;( ]$name[\&quot;) ]&quot;)  # interpolate value of name
r&quot;[\&quot;( ]Jon[\&quot;) ]&quot;

julia&gt; match(regex_name,&quot; Jon &quot;)
RegexMatch(&quot; Jon &quot;)

julia&gt; match(regex_name,&quot;[Jon]&quot;) === nothing
true</code></pre><h2 id="man-byte-array-literals"><a class="docs-heading-anchor" href="#man-byte-array-literals">バイト列リテラル</a><a id="man-byte-array-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-byte-array-literals" title="Permalink"></a></h2><p>もう一つの便利な非標準の文字列リテラルは，バイト配列の文字列リテラルである<code>b&quot;...&quot;</code>です．この形式では文字列記法を用いて，読み取り専用のバイト配列リテラルを表現することができます．すなわち，<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>値の配列です．これらのオブジェクトのタイプは，<code>CodeUnits{UInt8, String}</code>です．バイト配列リテラルのルールは以下の通りです:</p><ul><li>ASCII 文字と ASCII エスケープは 1 バイトを生成します．</li><li><code>\x</code>と 8 進数のエスケープシーケンスでは，エスケープ値に対応する <em>byte</em> が生成されます．</li><li>Unicode のエスケープシーケンスは，その符号位置を UTF-8 でエンコードしたバイト列を生成します．</li></ul><p><code>\x</code>と 0x80(128)以下の 8 進数エスケープの動作は，最初の 2 つのルールの両方でカバーされているため，これらのルールには重複がありますが，ここではこれらのルールは一致しています．これらのルールを合わせるとその規則により，ASCII 文字，任意のバイト値，UTF-8 シーケンスを使ってバイト配列を簡単に作成することができます．この 3 つを使った例を示します:</p><pre><code class="language-julia-repl">julia&gt; b&quot;DATA\xff\u2200&quot;
8-element Base.CodeUnits{UInt8,String}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80</code></pre><p>ASCII 文字列 &quot;DATA &quot;は，バイト 68，65，84，65 に対応します．<code>\xff</code>はシングルバイト 255 になります．Unicode のエスケープである<code>\u2200</code>は，UTF-8 では 226, 136, 128 の 3 バイトになります．なお，結果として得られるバイト配列は，有効な UTF-8 文字列には対応していないことに注意してください．</p><pre><code class="language-julia-repl">julia&gt; isvalid(&quot;DATA\xff\u2200&quot;)
false</code></pre><p>前述したように，<code>CodeUnits{UInt8,String}</code>型は<code>UInt8</code>の読み取り専用の配列のように動作します．標準的なベクトルが必要な場合は，<code>Vector{UInt8}</code>を使って変換できます:</p><pre><code class="language-julia-repl">julia&gt; x = b&quot;123&quot;
3-element Base.CodeUnits{UInt8,String}:
 0x31
 0x32
 0x33

julia&gt; x[1]
0x31

julia&gt; x[1] = 0x32
ERROR: setindex! not defined for Base.CodeUnits{UInt8,String}
[...]

julia&gt; Vector{UInt8}(x)
3-element Array{UInt8,1}:
 0x31
 0x32
 0x33</code></pre><p>また，<code>xff</code>と<code>uff</code>の大きな違いにも注目してください．前者のエスケープシーケンスは <em>byte 255</em> をエンコードしているのに対し，後者のエスケープシーケンスは <em>符号位置 255</em> を表しており，UTF-8 では 2 バイトでエンコードされています．</p><pre><code class="language-julia-repl">julia&gt; b&quot;\xff&quot;
1-element Base.CodeUnits{UInt8,String}:
 0xff

julia&gt; b&quot;\uff&quot;
2-element Base.CodeUnits{UInt8,String}:
 0xc3
 0xbf</code></pre><p>文字リテラルも同様の動作をします．</p><p><code>\u80</code>未満の符号位置では，各符号位置の UTF-8 エンコーディングは<code>\x</code>に対応したエスケープからが生成されるシングルバイトであるため，この区別は安全に無視できます．しかしながら<code>\x80</code> 〜<code>\xff</code>エスケープと<code>\u80</code> 〜 <code>\uff</code>のエスケープでは大きな違いがあります．前者のエスケープは，すべてシングルバイトをエンコードしており，特定の継続バイトが続かない限り，有効な UTF-8 データを形成しませんが，後者はすべて 2 バイトエンコードの Unicode の符号位置を表しています．</p><p>これだけではよくわからないという方は，<a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets”</a>を読んでみてください． これは Unicode と UTF-8 に関する優れた入門書で，この問題に役立つかもしれません．</p><h2 id="man-version-number-literals"><a class="docs-heading-anchor" href="#man-version-number-literals">バージョン番号リテラル</a><a id="man-version-number-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-version-number-literals" title="Permalink"></a></h2><p>バージョン番号は，<a href="../base/base.html#Base.@v_str"><code>v&quot;...&quot;</code></a>のような非標準の文字列リテラルで簡単に表現できます．バージョン番号リテラルは<a href="https://semver.org/">semantic versioning</a>の仕様に従った <a href="../base/base.html#Base.VersionNumber"><code>VersionNumber</code></a> オブジェクトを生成します．これは，メジャー・マイナー・パッチの数値から構成され，プレリリースやビルドの英数字による注釈が続きます．例えば，<code>v&quot;0.2.1-rc1+win64&quot;</code>はメジャーバージョン<code>0</code>，マイナーバージョン<code>2</code>，パッチバージョン<code>1</code>，プレリリース<code>rc1</code>，ビルド<code>win64</code>に分けられます．</p><p>バージョンリテラルを入力する際，メジャーバージョン番号以外はすべて省略可能です．そのため，例えば <code>v&quot;0.2&quot;</code> は <code>v&quot;0.2.0&quot;</code> (pre-release/build のアノテーションは空)，<code>v&quot;2&quot;</code> は <code>v&quot;2.0.0&quot;</code> などとなります．</p><p><code>VersionNumber</code> オブジェクトは，主に 2 つの（あるいはそれ以上の）バージョンを簡単かつ正確に比較するのに役立ちます．例えば，定数 <a href="../base/constants.html#Base.VERSION"><code>VERSION</code></a> は Julia のバージョン番号を <code>VersionNumber</code> オブジェクトとして保持しています．そのため，以下のような簡単な記述でバージョン固有の動作を定義することができます:</p><pre><code class="language-julia">if v&quot;0.2&quot; &lt;= VERSION &lt; v&quot;0.3-&quot;
    # do something specific to 0.2 release series
end</code></pre><p>上記では非標準のバージョン番号 <code>v&quot;0.3-&quot;</code> が使われており，最後に <code>-</code> が付いていることに注意してください．この表記法は標準の Julia 拡張で，プレリリースを含めたあらゆる<code>0.3</code>のリリースよりも下位のバージョンを示しています．したがって上記のコードは安定した <code>0.2</code> バージョンでのみ動作し， <code>v&quot;0.3.0-rc1&quot;</code> などのバージョンは除外されます． 不安定な（つまりプレリリースの）<code>0.2</code>バージョンも許容するための下限チェックは，次のようにできます: <code>v&quot;0.2-&quot; &lt;= VERSION</code></p><p>もうひとつの非標準的なバージョン指定の拡張機能として，末尾を<code>+</code> とすることでビルドバージョンの上限を表すことができます． 例えば，<code>VERSION &gt; v&quot;0.2-rc1+&quot;</code>とすると<code>0.2-rc1</code>よりも上のバージョンを有効なビルドバージョンとして示しており，<code>v&quot;0.2-rc1+win64&quot;</code>では<code>false</code>，<code>v&quot;0.2-rc2&quot;</code>では<code>true</code>を返します．</p><p>特別なバージョンを上のような比較で用いることは良いプラクティスです（特に，末尾の<code>-</code>は正当な理由がない限りは常に使用されるべきです）が，それらは実際のセマンティックバージョニングスキームではないので，実際のバージョン番号として使用するべきではありません．</p><p>さらに<a href="../base/constants.html#Base.VERSION"><code>VERSION</code></a>は定数として使われている他，<code>Pkg</code>モジュールではパッケージのバージョンとその依存関係を指定するために<code>VersionNumber</code>オブジェクトが広く使われています．</p><h2 id="man-raw-string-literals"><a class="docs-heading-anchor" href="#man-raw-string-literals">Raw 文字列リテラル</a><a id="man-raw-string-literals-1"></a><a class="docs-heading-anchor-permalink" href="#man-raw-string-literals" title="Permalink"></a></h2><p>補間やアンエスケープされていない raw 文字列は<code>raw&quot;...&quot;</code>という形式の非標準文字列で表現できます．また，raw 文字列リテラルは 通常の <code>String</code> オブジェクトを作成します．このオブジェクトは補間やエスケープを行わずに，入力された通りの内容を含みます．これは，コードや<code>$</code>や<code>\</code>を特殊文字として使用する他のマークアップ言語などを含む文字列の場合に便利です．</p><p>例外として，引用符は依然としてエスケープされなければなりません．例えば，<code>raw&quot;\&quot;&quot;</code>は <code>&quot;\&quot;&quot;</code> と等価です．すべての文字列を表現できるようにするために，バックスラッシュもエスケープする必要があります．ただし引用符の直前に記述された場合に限ります:</p><pre><code class="language-julia-repl">julia&gt; println(raw&quot;\\ \\\&quot;&quot;)
\\ \&quot;</code></pre><p>最初の 2 つのバックスラッシュは引用符の前ではないので，出力にそのまま現れます．しかし次のバックスラッシュはそれに続くバックスラッシュをエスケープし，最後のバックスラッシュは引用符の前にあるので引用符をエスケープします．</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="complex-and-rational-numbers.html">« 複素数と有理数</a><a class="docs-footer-nextpage" href="functions.html">Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 30 June 2021 12:55">Wednesday 30 June 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
