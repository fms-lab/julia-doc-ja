<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>パフォーマンスのヒント · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="variables.html">Variables</a></li><li><a class="tocitem" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="tocitem" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="functions.html">Functions</a></li><li><a class="tocitem" href="control-flow.html">Control Flow</a></li><li><a class="tocitem" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="types.html">Types</a></li><li><a class="tocitem" href="methods.html">Methods</a></li><li><a class="tocitem" href="constructors.html">Constructors</a></li><li><a class="tocitem" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li><a class="tocitem" href="modules.html">Modules</a></li><li><a class="tocitem" href="documentation.html">Documentation</a></li><li><a class="tocitem" href="metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="missing.html">Missing Values</a></li><li><a class="tocitem" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="parallel-computing.html">並列計算</a></li><li><a class="tocitem" href="asynchronous-programming.html">非同期プログラミング</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="distributed-computing.html">複数プロセス処理と分散計算</a></li><li><a class="tocitem" href="running-external-programs.html">外部プログラムの実行</a></li><li><a class="tocitem" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="handling-operating-system-variation.html">OSの違いへの対応</a></li><li><a class="tocitem" href="environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="code-loading.html">コードの読み込み</a></li><li><a class="tocitem" href="profile.html">プロファイリング</a></li><li><a class="tocitem" href="stacktraces.html">Stack Traces</a></li><li class="is-active"><a class="tocitem" href="performance-tips.html">パフォーマンスのヒント</a><ul class="internal"><li><a class="tocitem" href="#グローバル変数を避ける"><span>グローバル変数を避ける</span></a></li><li><a class="tocitem" href="#[@time](@ref)によるパフォーマンスの計測とメモリ割り当てへの注意"><span><code>@time</code>によるパフォーマンスの計測とメモリ割り当てへの注意</span></a></li><li><a class="tocitem" href="#tools"><span>ツール</span></a></li><li><a class="tocitem" href="#man-performance-abstract-container"><span>抽象型のパラメータを持つコンテナを避ける</span></a></li><li><a class="tocitem" href="#型宣言"><span>型宣言</span></a></li><li><a class="tocitem" href="#関数を複数の定義に分ける"><span>関数を複数の定義に分ける</span></a></li><li><a class="tocitem" href="#「型が安定している」関数を書く"><span>「型が安定している」関数を書く</span></a></li><li><a class="tocitem" href="#変数の型を変更することを避ける"><span>変数の型を変更することを避ける</span></a></li><li><a class="tocitem" href="#kernel-functions"><span>カーネル関数を分離する（別名，関数バリア）</span></a></li><li><a class="tocitem" href="#man-performance-value-type"><span>パラメータとしての値を持つ型</span></a></li><li><a class="tocitem" href="#複数のディスパッチを悪用する危険性（別名，パラメータとしての値を持つ型についての詳細）"><span>複数のディスパッチを悪用する危険性（別名，パラメータとしての値を持つ型についての詳細）</span></a></li><li><a class="tocitem" href="#man-performance-column-major"><span>列に沿ってメモリ順に配列にアクセスする</span></a></li><li><a class="tocitem" href="#Pre-allocating-outputs"><span>出力の事前割り当て</span></a></li><li><a class="tocitem" href="#さらなるドット:-ベクトル化された操作の融合"><span>さらなるドット: ベクトル化された操作の融合</span></a></li><li><a class="tocitem" href="#man-performance-views"><span>スライスのビューを使用することを検討する</span></a></li><li><a class="tocitem" href="#データをコピーすることは必ずしも悪いことではない"><span>データをコピーすることは必ずしも悪いことではない</span></a></li><li><a class="tocitem" href="#I/Oのための文字列補間を避ける"><span>I/Oのための文字列補間を避ける</span></a></li><li><a class="tocitem" href="#並列実行時のネットワークI/Oの最適化"><span>並列実行時のネットワークI/Oの最適化</span></a></li><li><a class="tocitem" href="#非推奨の警告を修正する"><span>非推奨の警告を修正する</span></a></li><li><a class="tocitem" href="#調整"><span>調整</span></a></li><li><a class="tocitem" href="#man-performance-annotations"><span>パフォーマンスアノテーション</span></a></li><li><a class="tocitem" href="#非正規化数をゼロとして扱う"><span>非正規化数をゼロとして扱う</span></a></li><li><a class="tocitem" href="#man-code-warntype"><span><code>@code_warntype</code>マクロ</span></a></li><li><a class="tocitem" href="#man-performance-captured"><span>キャプチャされた変数の性能</span></a></li><li class="toplevel"><a class="tocitem" href="#シングルトンでの同等性のチェック"><span>シングルトンでの同等性のチェック</span></a></li></ul></li><li><a class="tocitem" href="workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="style-guide.html">Style Guide</a></li><li><a class="tocitem" href="faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="unicode-input.html">Unicode Input</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="performance-tips.html">パフォーマンスのヒント</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="performance-tips.html">パフォーマンスのヒント</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fms-lab/julia-doc-ja/blob/main/doc/src/manual/performance-tips.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man-performance-tips"><a class="docs-heading-anchor" href="#man-performance-tips">パフォーマンスのヒント</a><a id="man-performance-tips-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-tips" title="Permalink"></a></h1><p>以下のセクションでは，Juliaのコードをできるだけ高速に動作させるためのいくつかのテクニックを 簡単に説明します．</p><h2 id="グローバル変数を避ける"><a class="docs-heading-anchor" href="#グローバル変数を避ける">グローバル変数を避ける</a><a id="グローバル変数を避ける-1"></a><a class="docs-heading-anchor-permalink" href="#グローバル変数を避ける" title="Permalink"></a></h2><p>グローバル変数の値と型はいつでも変更される可能性があります．これはグローバル変数を使用した コードをコンパイラが最適化するのを困難にします．変数は可能な限りローカルに定義するか，関数の 引数として渡すようにしてください．</p><p>パフォーマンスが重要なコードやベンチマークを行うコードは関数の中に入れるべきです．</p><p>グローバルな名前を持つものは定数であることが多く，定数であることを宣言することで， パフォーマンスが大幅に向上することがわかりました:</p><pre><code class="language-julia">const DEFAULT_VAL = 0</code></pre><p>定数ではないグローバル変数の使用は，使用時に型をアノテーションすることで最適化できます:</p><pre><code class="language-julia">global x = rand(1000)

function loop_over_global()
    s = 0.0
    for i in x::Vector{Float64}
        s += i
    end
    return s
end</code></pre><p>関数に引数を渡すのは，より良いスタイルです．関数に引数を渡すことは，コードの再利用性を高め， 入出力が何であるかを明確にします．</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>REPL内の全てのコードはグローバルスコープで評価されるので，トップレベルで定義され，代入 された変数は<strong>グローバル</strong>変数になります．モジュール内部のトップレベルスコープで定義さ れた変数もグローバルになります．</p></div></div><p>以下のREPLセッションの例では一つ目の式:</p><pre><code class="language-julia-repl">julia&gt; x = 1.0</code></pre><p>と以下の2つ目の式は等価です:</p><pre><code class="language-julia-repl">julia&gt; global x = 1.0</code></pre><p>ゆえに，上で議論された全てのパフォーマンスの問題が適用されます．</p><h2 id="[@time](@ref)によるパフォーマンスの計測とメモリ割り当てへの注意"><a class="docs-heading-anchor" href="#[@time](@ref)によるパフォーマンスの計測とメモリ割り当てへの注意"><a href="../base/base.html#Base.@time"><code>@time</code></a>によるパフォーマンスの計測とメモリ割り当てへの注意</a><a id="[@time](@ref)によるパフォーマンスの計測とメモリ割り当てへの注意-1"></a><a class="docs-heading-anchor-permalink" href="#[@time](@ref)によるパフォーマンスの計測とメモリ割り当てへの注意" title="Permalink"></a></h2><p>パフォーマンスの測定に便利なツールとして，<a href="../base/base.html#Base.@time"><code>@time</code></a>マクロがあります．ここでは上記の グローバル変数を使用した例を繰り返しますが，今回は型アノテーションを削除しています:</p><pre><code class="language-julia-repl">julia&gt; x = rand(1000);

julia&gt; function sum_global()
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia&gt; @time sum_global()
  0.017705 seconds (15.28 k allocations: 694.484 KiB)
496.84883432553846

julia&gt; @time sum_global()
  0.000140 seconds (3.49 k allocations: 70.313 KiB)
496.84883432553846</code></pre><p>最初に<code>@time sum_global()</code>を呼び出したときに，関数がコンパイルされます．（このセクションで <a href="../base/base.html#Base.@time"><code>@time</code></a>を使用していない場合は，計測に必要な関数もコンパイルされます．）この実行結果 を深刻に受け止めるべきではありません．2回目の実行では，時間を報告するだけでなく，かなりの量 のメモリが割り当てられていることに注意してください．ここでは64ビットの浮動小数点数のベクトル 内の全ての要素の和を計算しているだけなので，メモリを割り当てる必要がありません（少なくとも <code>@time</code>が報告するヒープ上での割り当ては必要ありません）．</p><p>予期せぬメモリ割り当ては，ほとんどの場合において，コードに何らかの問題があることを示していま す．これは通常，型の安定性に問題があったり，小さな一時的な配列をたくさん生成したりするような 問題です．その結果割り当て自体に加えて，関数のために生成されたコードが最適化されていない可能 性が非常に高いです．このような兆候は真剣に受け止めて，以下のアドバイスに従ってください．</p><p>上述の例で，<code>x</code>を引数として渡すように変更すると，メモリが割り当てられなくなり（以下で 報告されている割り当てはグローバルスコープで<code>@time</code>マクロを実行したことによるものです）， 最初の呼び出しの後には非常に高速に動作します:</p><pre><code class="language-julia-repl">julia&gt; x = rand(1000);

julia&gt; function sum_arg(x)
           s = 0.0
           for i in x
               s += i
           end
           return s
       end;

julia&gt; @time sum_arg(x)
  0.007701 seconds (821 allocations: 43.059 KiB)
496.84883432553846

julia&gt; @time sum_arg(x)
  0.000006 seconds (5 allocations: 176 bytes)
496.84883432553846</code></pre><p>例の中で5つ割り当てられているのは，グローバルスコープで<code>@time</code>を実行したことによるものです． 関数内で計測を行うように変更してから実行すると，確かにアロケーションが行われていないことが わかります:</p><pre><code class="language-julia-repl">julia&gt; time_sum(x) = @time sum_arg(x);

julia&gt; time_sum(x)
  0.000001 seconds
496.84883432553846</code></pre><p>状況によっては，関数がその操作の一部としてメモリを割り当てる必要がある場合があり，上記の 単純な状況を複雑にしてしまいます．そのような場合は，問題を診断するために以下の<a href="performance-tips.html#tools">tools</a> のいずれかを使用するか，アルゴリズム的な側面から割り当てを分離したバージョンの関数を書くこと を検討してください（<a href="performance-tips.html#Pre-allocating-outputs">出力の事前割り当て</a>を参照してください．</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>より本格的なベンチマークを行うには，<a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a> パッケージの利用を検討してください．これはノイズを減らすために関数を複数回評価します．</p></div></div><h2 id="tools"><a class="docs-heading-anchor" href="#tools">ツール</a><a id="tools-1"></a><a class="docs-heading-anchor-permalink" href="#tools" title="Permalink"></a></h2><p>Juliaとそのパッケージエコシステムには，問題を診断してコードのパフォーマンスを向上させるのに 役立つツールが含まれています:</p><ul><li><a href="profile.html#Profiling">Profiling</a>により，実行中のコードのパフォーマンスを測定し，ボトルネックとなる行を特定することができます．複雑なプロジェクトでは，<a href="https://github.com/timholy/ProfileView.jl">ProfileView</a>パッケージを使用sるうと，プロファイリング結果を可視化することができます．</li><li><a href="https://github.com/JunoLab/Traceur.jl">Traceur</a>パッケージは，コード内の一般的なパフォーマンスの問題を見つけるのに役立ちます．</li><li><a href="../base/base.html#Base.@time"><code>@time</code></a>や<a href="../base/base.html#Base.@allocated"><code>@allocated</code></a>，あるいは（ガベージコレクションルーチンへの呼び出しを通じた）プロファイラが報告するような予想外に大きなメモリ割り当ては，コードに問題があるかもしれないことを示唆しています．割り当てで他の問題が見つからない場合は，型の問題を疑ってください．また，Juliaを<code>--track-allocation=user</code>オプションをつけて起動し，結果として得られた<code>*.mem</code>ファイルを調べて，どこで割り当てが行われているかの情報を確認することもできます．<a href="profile.html#Memory-allocation-analysis">Memory allocation analysis</a>を参照してください．</li><li><code>@code_warntype</code>はコードの表現を生成し，型の不確実性をもたらす式を見つけるのに役立ちます．以下の<a href="../stdlib/InteractiveUtils.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>を参照してください．</li></ul><h2 id="man-performance-abstract-container"><a class="docs-heading-anchor" href="#man-performance-abstract-container">抽象型のパラメータを持つコンテナを避ける</a><a id="man-performance-abstract-container-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-abstract-container" title="Permalink"></a></h2><p>配列を含む，パラメータ化された型を扱う際には，可能な限り抽象型でのパラメータ化は避けた方が良いでしょう．</p><p>以下を考えてみましょう:</p><pre><code class="language-julia-repl">julia&gt; a = Real[]
Real[]

julia&gt; push!(a, 1); push!(a, 2.0); push!(a, π)
3-element Array{Real,1}:
 1
 2.0
 π = 3.1415926535897...</code></pre><p><code>a</code>は抽象型<a href="../base/numbers.html#Core.Real"><code>Real</code></a>の配列なので，任意の<code>Real</code>型の値を保持できなければなりません． <code>Real</code>オブジェクトは任意のサイズと構造を持つことができるので，<code>a</code>は個別に割り当てられた <code>Real</code>オブジェクトへのポインタの配列として表現されなければなりません．しかし，代わりに 同じ型の数値，例えば<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>などの数値だけを<code>a</code>に格納できるようにすれば，これら の数値をより効率的に格納することができます:</p><pre><code class="language-julia-repl">julia&gt; a = Float64[]
Float64[]

julia&gt; push!(a, 1); push!(a, 2.0); push!(a,  π)
3-element Array{Float64,1}:
 1.0
 2.0
 3.141592653589793</code></pre><p><code>a</code>に数値を代入すると<code>Float64</code>に変換され，<code>a</code>は64ビット浮動小数点数値の連続したブロックと して格納され，効率的に操作できるようになります．</p><p>以下の<a href="types.html#Parametric-Types">Parametric Types</a>の説明も参照してください．</p><h2 id="型宣言"><a class="docs-heading-anchor" href="#型宣言">型宣言</a><a id="型宣言-1"></a><a class="docs-heading-anchor-permalink" href="#型宣言" title="Permalink"></a></h2><p>型宣言がオプションとしてある多くの言語では，宣言を追加することがコードを高速に実行するため の主要な方法です．しかし，Juliaでは<em>そうではありません</em>．Juliaではコンパイラは通常，全ての 関数引数，ローカル変数，式の型を知っています．しかし，宣言な有用な例はいくつか存在します．</p><h3 id="抽象型のフィールドを避ける"><a class="docs-heading-anchor" href="#抽象型のフィールドを避ける">抽象型のフィールドを避ける</a><a id="抽象型のフィールドを避ける-1"></a><a class="docs-heading-anchor-permalink" href="#抽象型のフィールドを避ける" title="Permalink"></a></h3><p>型は，フィールドの型を指定せずに宣言することができます:</p><pre><code class="language-julia-repl">julia&gt; struct MyAmbiguousType
           a
       end</code></pre><p>これにより<code>a</code>に任意の型を指定することができます．これは便利ですが欠点もあります<code>MyAmbiguousType</code> 型のオブジェクトの場合，コンパイラは高性能なコードを生成できません．その理由は，コンパイラが コードのビルド方法を決定するために，値ではなくオブジェクトの型を使用するからです．残念ながら <code>MyAmbiguousType</code>型のオブジェクトについてはほとんど推論できません:</p><pre><code class="language-julia-repl">julia&gt; b = MyAmbiguousType(&quot;Hello&quot;)
MyAmbiguousType(&quot;Hello&quot;)

julia&gt; c = MyAmbiguousType(17)
MyAmbiguousType(17)

julia&gt; typeof(b)
MyAmbiguousType

julia&gt; typeof(c)
MyAmbiguousType</code></pre><p><code>b</code>と<code>c</code>は同じ型を持っていますが，メモリ上のデータの基本的な表現は全く異なっています． フィールド<code>a</code>に数値だけを格納したとしても，<a href="../base/numbers.html#Core.UInt8"><code>UInt8</code></a>のメモリ表現は<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> とは異なるという事実は，CPUが2種類の異なる命令を使用してそれらを処理する必要があることを 意味します．この型では必要な情報が得られないため，このような判断は実行時に行わなければ なりません．これがパフォーマンスを低下させます．</p><p><code>a</code>の型を宣言することによるより良い方法があります．ここでは<code>a</code>がいくつかの型のうちいずれか であるような場合に焦点を当てていますが，この場合の自然な解決策はパラメータを使うことです． 例えば:</p><pre><code class="language-julia-repl">julia&gt; mutable struct MyType{T&lt;:AbstractFloat}
           a::T
       end</code></pre><p>これは以下よりも優れています:</p><pre><code class="language-julia-repl">julia&gt; mutable struct MyStillAmbiguousType
           a::AbstractFloat
       end</code></pre><p>これは，最初のバージョンではラッパーオブジェクトの型から<code>a</code>の型を指定しているからです．例えば:</p><pre><code class="language-julia-repl">julia&gt; m = MyType(3.2)
MyType{Float64}(3.2)

julia&gt; t = MyStillAmbiguousType(3.2)
MyStillAmbiguousType(3.2)

julia&gt; typeof(m)
MyType{Float64}

julia&gt; typeof(t)
MyStillAmbiguousType</code></pre><p>フィールド<code>a</code>の型は，<code>m</code>の型から容易に決定できますが，<code>t</code>の型からは決定できません． 実際，<code>t</code>では，フィールド<code>a</code>の型を変更することができます:</p><pre><code class="language-julia-repl">julia&gt; typeof(t.a)
Float64

julia&gt; t.a = 4.5f0
4.5f0

julia&gt; typeof(t.a)
Float32</code></pre><p>これに対して，一度<code>m</code>が構成されると，<code>m.a</code>の型を変えることはできません:</p><pre><code class="language-julia-repl">julia&gt; m.a = 4.5f0
4.5f0

julia&gt; typeof(m.a)
Float64</code></pre><p><code>m.a</code>の型が<code>m</code>の型からわかっているという事実と，関数の途中で型が変更できないという事実が 組み合わさって，コンパイラは<code>m</code>のようなオブジェクトに対しては最適化されたコードを生成でき ますが，<code>t</code>のようばオブジェクトに対しては最適化されていません．</p><p>もちろん，これらは<code>m</code>を具体的な型で構築した場合にのみ有効です．明示的に抽象的な型で構成する ことでこれを破ることができます:</p><pre><code class="language-julia-repl">julia&gt; m = MyType{AbstractFloat}(3.2)
MyType{AbstractFloat}(3.2)

julia&gt; typeof(m.a)
Float64

julia&gt; m.a = 4.5f0
4.5f0

julia&gt; typeof(m.a)
Float32</code></pre><p>現実的には，このようなオブジェクトは<code>MyStillAmbiguousType</code>のものと同じように動作します．</p><p>単純な関数</p><pre><code class="language-julia">func(m::MyType) = m.a+1</code></pre><p>のために生成されるコードの量を，以下を用いて比較するのは非常に有益です:</p><pre><code class="language-julia">code_llvm(func, Tuple{MyType{Float64}})
code_llvm(func, Tuple{MyType{AbstractFloat}})</code></pre><p>長くなるのでここでは結果を示しませんが，ご自身で試してみたくなるかもしれません． 最初のケースでは型が完全に指定されているため，コンパイラは実行時に型を解決するコードを 生成する必要がありません．その結果，短く高速なコードが生成されます．</p><h3 id="Avoid-fields-with-abstract-containers"><a class="docs-heading-anchor" href="#Avoid-fields-with-abstract-containers">抽象的なコンテナを持つフィールドを避ける</a><a id="Avoid-fields-with-abstract-containers-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-fields-with-abstract-containers" title="Permalink"></a></h3><p>同じベストプラクティスはコンテナ型でも機能します:</p><pre><code class="language-julia-repl">julia&gt; struct MySimpleContainer{A&lt;:AbstractVector}
           a::A
       end

julia&gt; struct MyAmbiguousContainer{T}
           a::AbstractVector{T}
       end</code></pre><p>例えば:</p><pre><code class="language-julia-repl">julia&gt; c = MySimpleContainer(1:3);

julia&gt; typeof(c)
MySimpleContainer{UnitRange{Int64}}

julia&gt; c = MySimpleContainer([1:3;]);

julia&gt; typeof(c)
MySimpleContainer{Array{Int64,1}}

julia&gt; b = MyAmbiguousContainer(1:3);

julia&gt; typeof(b)
MyAmbiguousContainer{Int64}

julia&gt; b = MyAmbiguousContainer([1:3;]);

julia&gt; typeof(b)
MyAmbiguousContainer{Int64}</code></pre><p><code>MySimpleContainer</code>の場合，オブジェクトは型とパラメータで完全に指定されているので，コンパイ ラは最適化された関数を生成することができます．ほとんどの場合はこれで十分でしょう．</p><p>コンパイラはこれで完璧に仕事をこなせるようになりましたが，<code>a</code>の<em>要素の型</em>に応じてコードを 変えたい場合もあるかもしれません．通常これを実現する最良の方法は，特定の操作（ここでは<code>foo</code> ）を別の関数でラップすることです:</p><pre><code class="language-julia-repl">julia&gt; function sumfoo(c::MySimpleContainer)
           s = 0
           for x in c.a
               s += foo(x)
           end
           s
       end
sumfoo (generic function with 1 method)

julia&gt; foo(x::Integer) = x
foo (generic function with 1 method)

julia&gt; foo(x::AbstractFloat) = round(x)
foo (generic function with 2 methods)</code></pre><p>これにより，シンプルさを保ちながら，全てのケースでコンパイラが最適化されたコードを生成できるようになります．</p><p>しかし，異なる要素の型や，<code>MySimpleContainer</code>のフィールド<code>a</code>の<code>AbstractVector</code>の型ごとに 異なるバージョンの外部関数を宣言する必要が場合もあるでしょう．それは以下のようにできます:</p><pre><code class="language-julia-repl">julia&gt; function myfunc(c::MySimpleContainer{&lt;:AbstractArray{&lt;:Integer}})
           return c.a[1]+1
       end
myfunc (generic function with 1 method)

julia&gt; function myfunc(c::MySimpleContainer{&lt;:AbstractArray{&lt;:AbstractFloat}})
           return c.a[1]+2
       end
myfunc (generic function with 2 methods)

julia&gt; function myfunc(c::MySimpleContainer{Vector{T}}) where T &lt;: Integer
           return c.a[1]+3
       end
myfunc (generic function with 3 methods)</code></pre><pre><code class="language-julia-repl">julia&gt; myfunc(MySimpleContainer(1:3))
2

julia&gt; myfunc(MySimpleContainer(1.0:3))
3.0

julia&gt; myfunc(MySimpleContainer([1:3;]))
4</code></pre><h3 id="型付けされていない場所から取得した値をアノテーションする"><a class="docs-heading-anchor" href="#型付けされていない場所から取得した値をアノテーションする">型付けされていない場所から取得した値をアノテーションする</a><a id="型付けされていない場所から取得した値をアノテーションする-1"></a><a class="docs-heading-anchor-permalink" href="#型付けされていない場所から取得した値をアノテーションする" title="Permalink"></a></h3><p>任意の型の値を含むデータ構造体（<code>Array{Any}</code>型の配列）を扱うのは便利です．しかし，これらの 構造体を使用していて，たまたま要素の型を知っている場合は，その知識をコンパイラと共有するのに役立ちます:</p><pre><code class="language-julia">function foo(a::Array{Any,1})
    x = a[1]::Int32
    b = x+1
    ...
end</code></pre><p>ここでは，<code>a</code>の最初の要素が<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a>であることを知っているものとします．このような アノテーションを作成することで，値が期待される型でない場合にランタイムエラーを発生させ， 特定のバグを早期に発見できる可能性があるという利点があります．</p><p><code>a[1]</code>の型が正確にわからない場合は，<code>x = convert(Int32, a[1])::Int32</code>で<code>x</code>を宣言することが できます．<a href="../base/base.html#Base.convert"><code>convert</code></a>関数を使用することで，<code>a[1]</code>は<code>Int32</code>に変換可能な任意のオブジェ クト（<code>UInt8</code>など）になり，型の要件を緩くすることでコードの汎用性が高まります．型の安定性 を実現するために，この文脈では<code>convert</code>自体に型アノテーションが必要であることに注意してくだ さい．これはある関数の全ての引数の型が既知でなければ，たとえ<code>convert</code>関数であっても，コンパ イラが関数の戻り値の型を推測することができないためです．</p><p>型のアノテーションは実行時に型が構築されている場合，パフォーマンスを向上させることはできませ ん（実際には妨げになることもあります）．これは，コンパイラがアノテーションを使用して後続の コードを特殊化することができず，型チェック自体に時間がかかるからです．例えばコードの中では:</p><pre><code class="language-julia">function nr(a, prec)
    ctype = prec == 32 ? Float32 : Float64
    b = Complex{ctype}(a)
    c = (b + 1.0f0)::Complex{ctype}
    abs(c)
end</code></pre><p><code>c</code>のアノテーションはパフォーマンスに悪影響を与えます．実行時に構築された型を含むパフォーマ ンスの高いコードを書くには，後述する<a href="performance-tips.html#kernel-functions">function-barrier technique</a>を 使用し，カーネル関数の引数型の中に構築された型が現れるようにして，コンパイラがカーネル操作を 適切に特殊化できるようにします．例えば，上のスニペットでは，<code>b</code>が構築されるとすぐに，それを カーネルである別の関数<code>k</code>に渡すことができます．例えば，関数<code>k</code>が<code>b</code>を<code>Complex{T}</code>型の引数と して宣言し，<code>T</code>が型パラメータである場合，<code>k</code>内の代入文に現れる型アノテーションは次のような 形になります:</p><pre><code class="language-julia">c = (b + 1.0f0)::Complex{T}</code></pre><p>これは<code>k</code>がコンパイルされた時点でコンパイラが<code>c</code>の型を決定することができるため，性能に 支障をきたすことはありません（が，助けにもなりません）．</p><h3 id="Juliaが特殊化を避ける場合に注意する"><a class="docs-heading-anchor" href="#Juliaが特殊化を避ける場合に注意する">Juliaが特殊化を避ける場合に注意する</a><a id="Juliaが特殊化を避ける場合に注意する-1"></a><a class="docs-heading-anchor-permalink" href="#Juliaが特殊化を避ける場合に注意する" title="Permalink"></a></h3><p>ヒューリスティックな方法として，Juliaは3つの特定のケースで引数の型パラメータを自動的に特殊化 することを避けます．<code>Type</code>，<code>Function</code>と<code>Vararg</code>です．引数がメソッド内で使用される場合， Juliaは常に特殊化しますが，引数が他の関数に渡されただけの場合は特殊化しません．これは通常， 実行時のパフォーマンスへの影響はなく，<a href="../devdocs/functions.html#compiler-efficiency-issues">コンパイラのパフォーマンスを向上させます</a>． 実行時にパフォーマンスに影響があることがわかった場合は，メソッド宣言に型パラメータを追加する ことで，特殊化をトリガすることができます．以下にいくつかの例を示します:</p><p>これは特殊化しません:</p><pre><code class="language-julia">function f_type(t)  # or t::Type
    x = ones(t, 10)
    return sum(map(sin, x))
end</code></pre><p>これは特殊化します:</p><pre><code class="language-julia">function g_type(t::Type{T}) where T
    x = ones(T, 10)
    return sum(map(sin, x))
end</code></pre><p>これは特殊化しません:</p><pre><code class="language-julia">f_func(f, num) = ntuple(f, div(num, 2))
g_func(g::Function, num) = ntuple(g, div(num, 2))</code></pre><p>これは特殊化します:</p><pre><code class="language-julia">h_func(h::H, num) where {H} = ntuple(h, div(num, 2))</code></pre><p>これは特殊化しません:</p><pre><code class="language-julia">f_vararg(x::Int...) = tuple(x...)</code></pre><p>これは特殊化します:</p><pre><code class="language-julia">g_vararg(x::Vararg{Int, N}) where {N} = tuple(x...)</code></pre><p>他の型が制約されていない場合でも強制的に特殊化を行うためには，1つの型のパラメータを導入する だけでよいです．例えば，これも特殊化され，引数が全て同じ型ではない場合にも便利です．</p><pre><code class="language-julia">h_vararg(x::Vararg{Any, N}) where {N} = tuple(x...)</code></pre><p>Juliaが通常そのメソッド呼び出しを特殊化しない場合でも，<a href="../stdlib/InteractiveUtils.html#InteractiveUtils.@code_typed"><code>@code_typed</code></a>とフレンドは 常に特殊化されたコードを表示することに注意してください．引数の型が変更された時に特殊化が 生成されるかどうか，つまり<code>(@which f(...)).specializations</code>に問題の引数の特殊化が含まれて いるかどうかを確認したい場合は，<a href="../devdocs/ast.html#ast-lowered-method">メソッド内部</a>をチェックする必要 があります．</p><h2 id="関数を複数の定義に分ける"><a class="docs-heading-anchor" href="#関数を複数の定義に分ける">関数を複数の定義に分ける</a><a id="関数を複数の定義に分ける-1"></a><a class="docs-heading-anchor-permalink" href="#関数を複数の定義に分ける" title="Permalink"></a></h2><p>関数を多くの小さな定義として書くことで，コンパイラが直接最も適用可能なコードを呼び出すことが できますし，インライン化することもできます．</p><p>ここでは実際には複数の定義として記述されるべき「複合関数」の例を示します:</p><pre><code class="language-julia">using LinearAlgebra

function mynorm(A)
    if isa(A, Vector)
        return sqrt(real(dot(A,A)))
    elseif isa(A, Matrix)
        return maximum(svdvals(A))
    else
        error(&quot;mynorm: invalid argument&quot;)
    end
end</code></pre><p>これは以下のように書くと，より簡潔かつ効率的に書くことができます:</p><pre><code class="language-julia">norm(x::Vector) = sqrt(real(dot(x, x)))
norm(A::Matrix) = maximum(svdvals(A))</code></pre><p>ただし，コンパイラは<code>mynorm</code>の例のように記述されたコードのデッドブランチを最適化するのに 非常に効率的であることに注意してください．</p><h2 id="「型が安定している」関数を書く"><a class="docs-heading-anchor" href="#「型が安定している」関数を書く">「型が安定している」関数を書く</a><a id="「型が安定している」関数を書く-1"></a><a class="docs-heading-anchor-permalink" href="#「型が安定している」関数を書く" title="Permalink"></a></h2><p>可能な場合，関数が常に同じ型の値を返すようにするのが役立ちます．次の定義を考えてみましょう:</p><pre><code class="language-julia">pos(x) = x &lt; 0 ? 0 : x</code></pre><p>これは十分に悪くないように見えますが，問題は<code>0</code>が整数型（<code>Int</code>型）であり，<code>x</code>が任意型である 可能性があるということです．したがって<code>x</code>の値によっては，この関数は2つの型のどちらかの値を 返すことになります．この動作は許容されており，いくつかのケースでは望ましいかもしれません． しかし，以下のように簡単に修正することができます:</p><pre><code class="language-julia">pos(x) = x &lt; 0 ? zero(x) : x</code></pre><p>また<a href="../base/numbers.html#Base.oneunit"><code>oneunit</code></a>関数や，より一般的な<a href="../base/base.html#Base.oftype"><code>oftype(x, y)</code></a>関数もあり，これは<code>x</code>の型に 変換された<code>y</code>を返します．</p><h2 id="変数の型を変更することを避ける"><a class="docs-heading-anchor" href="#変数の型を変更することを避ける">変数の型を変更することを避ける</a><a id="変数の型を変更することを避ける-1"></a><a class="docs-heading-anchor-permalink" href="#変数の型を変更することを避ける" title="Permalink"></a></h2><p>関数内で繰り返し使用される変数には，類似の「型安定性」の問題が存在します:</p><pre><code class="language-julia">function foo()
    x = 1
    for i = 1:10
        x /= rand()
    end
    return x
end</code></pre><p>ローカル変数<code>x</code>は整数で始まり，1回ループした後には浮動小数点数（<a href="../base/math.html#Base.:/"><code>/</code></a>演算子の結果）に なります．これによりコンパイラがループの本体を最適化するのが難しくなります．いくつかの修正 方法が考えられます:</p><ul><li><code>x</code>を<code>x = 1.0</code>で初期化する</li><li><code>x</code>の型を明示的に<code>x::Float64 = 1</code>として宣言する</li><li><code>x = oneunit(Float64)</code>による明示的な変換を使用する</li><li>最初のループの際に<code>x = 1 / rand()</code>で初期化してから，<code>for i = 2:10</code>をループします</li></ul><h2 id="kernel-functions"><a class="docs-heading-anchor" href="#kernel-functions">カーネル関数を分離する（別名，関数バリア）</a><a id="kernel-functions-1"></a><a class="docs-heading-anchor-permalink" href="#kernel-functions" title="Permalink"></a></h2><p>多くの関数は，いくつかの設定を実行した後，コア計算を実行するために何度も繰り返しを実行する というパターンに従っています．可能であれば，これらのコア計算は別の関数で行うことをお勧め します．例えば次のように不自然な関数は，ランダムに選ばれた型の配列を返します:</p><pre><code class="language-julia-repl">julia&gt; function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           for i = 1:n
               a[i] = 2
           end
           return a
       end;

julia&gt; strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0</code></pre><p>これは次のように書くべきです:</p><pre><code class="language-julia-repl">julia&gt; function fill_twos!(a)
           for i = eachindex(a)
               a[i] = 2
           end
       end;

julia&gt; function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)
           fill_twos!(a)
           return a
       end;

julia&gt; strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0</code></pre><p>Juliaのコンパイラは関数の境界で引数の型のコードを特殊化しているので，オリジナルの実装では ループの間の<code>a</code>の型を知りません（ランダムに選ばれているので）．そのため，異なる型の<code>a</code>に 対して，内側のループを<code>fill_twos!</code>の一部として再コンパイルできるため，2番目のバージョンは 一般的に高速になります．</p><p>また，2番目の形式の方がスタイルがよく，コードの再利用性が高まります．</p><p>このパターンはJulia Baseのいくつかの場所で使われています．例えば，<a href="https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206"><code>abstractarray.jl</code></a>の <code>vcat</code>や<code>hcat</code>，あるいは<a href="../base/arrays.html#Base.fill!"><code>fill!</code></a>関数を見てください．<a href="../base/arrays.html#Base.fill!"><code>fill!</code></a>関数は，上で独自に 書いた<code>fill_twos!</code>の代わりに使うことができます．</p><p><code>strange_twos</code>のような関数は，例えば入力ファイルから読み込まれたデータが整数，浮動小数点数， 文字列，その他の何らかの型のものを含んでいるような，型が不確かなデータを扱うときに発生します．</p><h2 id="man-performance-value-type"><a class="docs-heading-anchor" href="#man-performance-value-type">パラメータとしての値を持つ型</a><a id="man-performance-value-type-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-value-type" title="Permalink"></a></h2><p>各軸に沿ったサイズが3の<code>N</code>次元配列を作成したいとしましょう．このような配列は以下のように作成できます:</p><pre><code class="language-julia-repl">julia&gt; A = fill(5.0, (3, 3))
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0</code></pre><p>このアプローチは非常にうまく機能します．コンパイラはfill値（<code>5.0::Float64</code>）と次元数（ <code>(3, 3)::NTuple{2,Int}</code>）を知っているので，<code>A</code>が<code>Array{Float64,2}</code>であることがわかります． このことは，コンパイラが将来同じ関数で<code>A</code>を使用する際に，非常に効率的なコードを生成できる ことを意味しています．</p><p>しかしここで，任意の次元の3×3×...配列を作成する関数を書きたいとしましょう．次のような 関数を書きたくなるかもしれません:</p><pre><code class="language-julia-repl">julia&gt; function array3(fillval, N)
           fill(fillval, ntuple(d-&gt;3, N))
       end
array3 (generic function with 1 method)

julia&gt; array3(5.0, 2)
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0</code></pre><p>これは動作しますが，（<code>@code_warntype array3(5.0, 2)</code>を使って確認できるように，）問題は出力 の型を推測できないことです．引数<code>N</code>は<code>Int</code>型の<em>値</em>であり，型推論ではその値を事前に予測する ことはしませんし，できません．これは，この関数の出力を使用するコードは<code>A</code>へアクセスするたび に型をチェックするような保守的なものでなければならないことを意味します．このようなコードは 非常に遅くなります．</p><p><a href="types.html#&quot;Value-types&quot;">&quot;Value types&quot;</a>): さて，このような問題を解決するための非常に良い方法の一つが<a href="performance-tips.html#kernel-functions">関数バリアテクニック</a>です． しかし場合によっては，型の不安定性を完全に排除したいとい思うかもしれません．そのような場合， 1つの方法として，例えば<code>Val{T}()</code>を通して次元性をパラメータを渡すものがあります（<a href="types.html#&quot;Value-types&quot;">&quot;Value types&quot;</a>を参照してください）．</p><pre><code class="language-julia-repl">julia&gt; function array3(fillval, ::Val{N}) where N
           fill(fillval, ntuple(d-&gt;3, Val(N)))
       end
array3 (generic function with 1 method)

julia&gt; array3(5.0, Val(2))
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0</code></pre><p>Juliaには，2番目のパラメータとして<code>Val{::Int}</code>インスタンスを受け付ける特殊なバージョンの <code>ntuple</code>があります．<code>N</code>を型パラメータとして渡すことで，その「値」をコンパイラに知らせること ができます．その結果，このバージョンの<code>array3</code>では，コンパイラが戻り値の型を予測することが できます．</p><p>しかし，このようなテクニックを利用することは，驚くほど微妙なことです．例えば，次のような関数 から<code>array3</code>を呼び出しても何の役にも立ちません:</p><pre><code class="language-julia">function call_array3(fillval, n)
    A = array3(fillval, Val(n))
end</code></pre><p>この場合，同じ問題を繰り返してしまいます．コンパイラは<code>n</code>が何であるかを推測できないので， <code>Val(n)</code>の<em>型</em>を知りません．<code>Val</code>を使おうとしても，それを誤って行うと，多くの状況でパフォーマンス が悪化します．（カーネル関数をより効率にするために，<code>Val</code>と関数バリアのトリックを効果的に 組み合わせている状況でのみ，上記のようなコードを使うべきです．）</p><p><code>Val</code>の正しい使い方の例は次のようになります:</p><pre><code class="language-julia">function filter3(A::AbstractArray{T,N}) where {T,N}
    kernel = array3(1, Val(N))
    filter(A, kernel)
end</code></pre><p>この例では，<code>N</code>はパラメータとして渡されるので，その「値」はコンパイラに知られます．基本的に <code>Val(T)</code>は，<code>T</code>がハードコーディングされているか，リテラル（<code>Val(3)</code>）であるか，あるいは既に タイプドメインで指定されている場合にのみ動作します．</p><h2 id="複数のディスパッチを悪用する危険性（別名，パラメータとしての値を持つ型についての詳細）"><a class="docs-heading-anchor" href="#複数のディスパッチを悪用する危険性（別名，パラメータとしての値を持つ型についての詳細）">複数のディスパッチを悪用する危険性（別名，パラメータとしての値を持つ型についての詳細）</a><a id="複数のディスパッチを悪用する危険性（別名，パラメータとしての値を持つ型についての詳細）-1"></a><a class="docs-heading-anchor-permalink" href="#複数のディスパッチを悪用する危険性（別名，パラメータとしての値を持つ型についての詳細）" title="Permalink"></a></h2><p>一度複数のディスパッチのありがたみを知ると，行き過ぎて全てのことに使おうとする傾向があるのは 理解できます．例えば，以下の例のような情報を格納するためにこれを使い， <code>Car{:Honda,:Accord}(year, args...)</code>のようなオブジェクトにディスパッチすることを想像してみて ください:</p><pre><code class="language-none">struct Car{Make, Model}
    year::Int
    ...more fields...
end</code></pre><p>以下のいずれかに当てはまる場合には，この方法は価値があるかもしれません:</p><ul><li><code>Car</code>ごとにCPU負荷の高い処理を必要とし，コンパイル時に<code>Make</code>と<code>Model</code>がわかっていて，使用される<code>Make</code>と<code>Model</code>の総数が多すぎない場合は，はるかに効率的になります．</li><li>同じ種類の<code>Car</code>を処理するための均質なリストを持っているので，それらを全て<code>Array{Car{:Honda,:Accord},N}</code>に格納することができます．</li></ul><p>後者の場合，このような均質な配列を処理する関数は生産的に特殊化することができます．Juliaは各 要素の型を事前に知っているので（コンテナ内のオブジェクトは全て同じ具体的な型を持つ）， 関数のコンパイル時に正しいメソッド呼び出しを「検索」することができ（実行時のチェックが不要に なる），リスト全体を処理するための効率的なコードを出すことができます．</p><p>これらが保持されない場合には，何の利益も得られない可能性が高いです．さらに悪いことに， 結果として生じる「型の組み合わせ爆発」は逆効果となります．<code>items[i+1]</code>が<code>items[i]</code>と異なる 型を持っている場合，Juliaは実行時にそれらの型を調べ，メソッドテーブルから適切なメソッドを 検索し，（型の共通部分を介して）どれがマッチするかを判断し，それが既にJITコンパイルされて いるかどうかを判断し（されていない場合はそうします），そして呼び出しをしなければなりません． 要するに，完全な型システムとJITコンパイル機構に，基本的にはスイッチ文や辞書検索に相当する ものを，自分のコードで実行するように頼んでいることになります．</p><p>(1)型のディスパッチ，(2)辞書検索，(3)「スイッチ」文を比較したランタイムベンチマークが <a href="https://groups.google.com/forum/#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ">メーリングリスト</a> で公開されています．</p><p>おそらく実行時の影響よりもさらに悪いのはコンパイル時の影響です．Juliaは<code>Car{Make, Model}</code> ごとに専用の関数をコンパイルします．もしそのような型を何百，何千も持っている場合，そのような オブジェクトをパラメータとして受け取る全ての関数（自分で書いたカスタムの<code>get_year</code>関数から Julia Baseの一般的な<code>push!</code>関数まで）は，何百，何千ものバリエーションをコンパイルしなければ なりません．これらはそれぞれ，コンパイルされたコードのキャッシュサイズやメソッドの内部リスト の長さなどを増加させます．パラメータとしての値に過度に熱中すると，膨大なリソースを簡単に浪費 してしまいます．</p><h2 id="man-performance-column-major"><a class="docs-heading-anchor" href="#man-performance-column-major">列に沿ってメモリ順に配列にアクセスする</a><a id="man-performance-column-major-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-column-major" title="Permalink"></a></h2><p>Juliaの多次元配列は，列メジャーな順序で格納されます．これは配列が一度に一列ずつ積み重ね られることを意味します．これは次のように<code>vec</code>関数や<code>[:]</code>構文を使って確認できます（配列の 順番は<code>[1 2 3 4]</code>ではなく，<code>[1 3 2 4]</code>であることに注意してください）:</p><pre><code class="language-julia-repl">julia&gt; x = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; x[:]
4-element Array{Int64,1}:
 1
 3
 2
 4</code></pre><p>この配列の順序付けの規則は，Fortran，Matlab，Rなど多くの言語で共通しています．列メジャー 順序の代替として，行メジャー順序があります．これは，他の言語の中でもC言語やPython(<code>numpy</code>） で採用されている規則です．配列の順序を覚えておくと，配列をループする際にパフォーマンスに 大きな影響を与えることがあります．覚えておくべき経験則としては，列メジャー配列の場合，最初 のインデックスが最も速く変化するということです．これは基本的に，ループインデックスの一番内側 がスライス式の最初のインデックスである場合，ループ処理が速くなることを意味します．配列に<code>:</code> でインデックスをつけることは，特定の次元内の全ての要素に反復的にアクセスする暗黙のループで あることを覚えておいてください．例えば，行よりも列を抽出する方が速くなることがあります．</p><p>次の例を考えてみましょう．<a href="../base/arrays.html#Base.Vector"><code>Vector</code></a>を受け取り，入力ベクトルのコピーで行または列を 埋めた正方<a href="../base/arrays.html#Base.Matrix"><code>Matrix</code></a>を返す関数を書きたいとします．行または列がコピーで埋められているか どうかは，重要ではないと仮定します（おそらく，コードの残りの部分はそれに応じて簡単に適応 させることができます）．少なくとも4つの方法でこれを行うことができます（推奨されている 組み込みの<a href="../base/arrays.html#Base.repeat"><code>repeat</code></a>の呼び出しに加えて）:</p><pre><code class="language-julia">function copy_cols(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[:, i] = x
    end
    return out
end

function copy_rows(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for i = inds
        out[i, :] = x
    end
    return out
end

function copy_col_row(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for col = inds, row = inds
        out[row, col] = x[row]
    end
    return out
end

function copy_row_col(x::Vector{T}) where T
    inds = axes(x, 1)
    out = similar(Array{T}, inds, inds)
    for row = inds, col = inds
        out[row, col] = x[col]
    end
    return out
end</code></pre><p>今，我々は同じランダム<code>10000 x 1</code>の入力ベクトルを使用して，これらの関数のそれぞれの時間を計測します:</p><pre><code class="language-julia-repl">julia&gt; x = randn(10000);

julia&gt; fmt(f) = println(rpad(string(f)*&quot;: &quot;, 14, &#39; &#39;), @elapsed f(x))

julia&gt; map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);
copy_cols:    0.331706323
copy_rows:    1.799009911
copy_col_row: 0.415630047
copy_row_col: 1.721531501</code></pre><p><code>copy_cols</code>は<code>copy_rows</code>よりもとても高速であることに注目してください．これは，<code>copy_cols</code>が 行列の列ベースのメモリレイアウトを尊重し，一度に一列ずつ埋めていくからです．さらに，<code>copy_col_row</code>は <code>copy_row_col</code>よりもはるかに高速です．これはスライス式に最初に現れる要素は最も内側のループに 結合されるべきであるという経験則にしたがっているからです．</p><h2 id="Pre-allocating-outputs"><a class="docs-heading-anchor" href="#Pre-allocating-outputs">出力の事前割り当て</a><a id="Pre-allocating-outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-allocating-outputs" title="Permalink"></a></h2><p>関数が<code>Array</code>やその他の複雑な型を返す場合，メモリを確保する必要があるかもしれません． 残念なことに，メモリの割り当てとその逆であるガベージコレクションがボトルネックになることが よくあります．</p><p>場合によっては出力を事前に確保することで，関数の呼び出しごとにメモリを確保する必要性を 回避できることもあります．簡単な例として，次の2つの例を比較してみましょう:</p><pre><code class="language-julia-repl">julia&gt; function xinc(x)
           return [x, x+1, x+2]
       end;

julia&gt; function loopinc()
           y = 0
           for i = 1:10^7
               ret = xinc(i)
               y += ret[2]
           end
           return y
       end;</code></pre><p>と</p><pre><code class="language-julia-repl">julia&gt; function xinc!(ret::AbstractVector{T}, x::T) where T
           ret[1] = x
           ret[2] = x+1
           ret[3] = x+2
           nothing
       end;

julia&gt; function loopinc_prealloc()
           ret = Vector{Int}(undef, 3)
           y = 0
           for i = 1:10^7
               xinc!(ret, i)
               y += ret[2]
           end
           return y
       end;</code></pre><p>です．計測の結果は以下のようになります:</p><pre><code class="language-julia-repl">julia&gt; @time loopinc()
  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)
50000015000000

julia&gt; @time loopinc_prealloc()
  0.030850 seconds (6 allocations: 288 bytes)
50000015000000</code></pre><p>例えば，呼び出し元がアルゴリズムからの「出力」の型を制御できるようになるなど，他にも事前 割り当ての利点があります．上の例では，必要に応じて，<a href="../base/arrays.html#Core.Array"><code>Array</code></a>ではなく，<code>SubArray</code>を 渡すことができました．</p><p>極端に言えば，事前割り当てはコードを醜くする可能性があるので，パフォーマンスの測定やある程度 の判断が必要になるかもしれません．しかし，「ベクトル化された」（要素ごとの）関数の場合， 便利な構文<code>x .= f.(y)</code>は融合ループと一時的な配列を使わないインプレース操作に使用できます （<a href="functions.html#man-vectorized">関数をベクトル化するためのドット構文</a>を参照してください）．</p><h2 id="さらなるドット:-ベクトル化された操作の融合"><a class="docs-heading-anchor" href="#さらなるドット:-ベクトル化された操作の融合">さらなるドット: ベクトル化された操作の融合</a><a id="さらなるドット:-ベクトル化された操作の融合-1"></a><a class="docs-heading-anchor-permalink" href="#さらなるドット:-ベクトル化された操作の融合" title="Permalink"></a></h2><p>Juliaには特別な<a href="functions.html#man-vectorized">ドット構文</a>があり，これはスカラ関数を 「ベクトル化された」関数呼び出しに変換し，演算子を「ベクトル化された」演算子に 変換するもので，入れ子になった「ドット呼び出し」が<em>融合</em>するという特別な性質 を持っています．これらは一般的な配列を確保することなく，構文レベルで単一の ループに結合されます．<code>.=</code>や同様の代入演算子を使用した場合，結果は事前に割り当て られた配列にその場で保存することもできます（上述）．</p><p>線形代数の文脈では，<code>vector + vector</code>や<code>vector * scalar</code>のような演算が定義されて いても，結果のループを周りの計算と融合させることができるため，代わりに<code>vector .+ vector</code> や<code>vector .* scalar</code>を使用することが有利になることを意味しています．例えば， 以下の2つの関数を考えてみましょう:</p><pre><code class="language-julia-repl">julia&gt; f(x) = 3x.^2 + 4x + 7x.^3;

julia&gt; fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3;</code></pre><p><code>f</code>と<code>fdot</code>はいずれも同じことを計算します．しかし，配列を使用した場合， <code>fdot</code>（<a href="../base/arrays.html#Base.Broadcast.@__dot__"><code>@.</code></a>マクロの助けを借りて定義されたもの）の方が はるかに高速に動作します:</p><pre><code class="language-julia-repl">julia&gt; x = rand(10^6);

julia&gt; @time f(x);
  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)

julia&gt; @time fdot(x);
  0.002790 seconds (6 allocations: 7.630 MiB)

julia&gt; @time f.(x);
  0.002626 seconds (8 allocations: 7.630 MiB)</code></pre><p>つまり，<code>fdot(x)</code>は10倍速く，<code>f(x)</code>の1/6のメモリしか確保しません．これは， <code>f(x)</code>の<code>*</code>と<code>+</code>の各操作が新しい一時的な配列を確保し，別のループで実行される からです．（もちろん，単に<code>f.(x)</code>を実行するだけならば，この例の<code>fdot(x)</code>と同じ くらい高速ですが，多くの文脈では，ベクトル化された各演算のために個別の関数を 定義するよりも，式の中にドットをちりばめるだけの方が便利です）．</p><h2 id="man-performance-views"><a class="docs-heading-anchor" href="#man-performance-views">スライスのビューを使用することを検討する</a><a id="man-performance-views-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-views" title="Permalink"></a></h2><p>Juliaでは，<code>array[1:5, :]</code>のような配列の「スライス」式は，そのデータのコピー を作成します（代入の左側に書かれるような場合，すなわち<code>array[1:5, :] = ...</code>が <code>array</code>のその部分にインプレースで代入されるような場合を除く）．スライスに対して 多くの操作を行っている場合，元の配列にインデックスを作成するよりも，より小さい 連続コピーを使用した方が効率的に作業ができるため，これはパフォーマンスの面で 良いことがあります．一方で，スライスに対していくつかの単純な作業を行うだけの 場合は，割り当てとコピー操作のコストが大きくなってしまう可能性もあります．</p><p>別の方法として，配列の「ビュー」を作成する方法があります．これは 配列オブジェクト（<code>SubArray</code>）で，コピーを行わずに元の配列のデータ をその場で実際に参照します．（ビューに書き込むと，元の配列のデータ も変更されます．）これは個々のスライスに対しては<a href="../base/arrays.html#Base.view"><code>view</code></a>を呼び 出すことによって行うことができますし，より単純に式全体やコードブロックに 対しては，式の前に<a href="../base/arrays.html#Base.@views"><code>@views</code></a>を置くことで行うことができます． 例えば以下のようになります:</p><pre><code class="language-julia-repl">julia&gt; fcopy(x) = sum(x[2:end-1]);

julia&gt; @views fview(x) = sum(x[2:end-1]);

julia&gt; x = rand(10^6);

julia&gt; @time fcopy(x);
  0.003051 seconds (7 allocations: 7.630 MB)

julia&gt; @time fview(x);
  0.001020 seconds (6 allocations: 224 bytes)</code></pre><p>この関数の<code>fview</code>バージョンが，3倍の高速化と，メモリ割り当て量の 減少の双方を達成していることに注目してください．</p><h2 id="データをコピーすることは必ずしも悪いことではない"><a class="docs-heading-anchor" href="#データをコピーすることは必ずしも悪いことではない">データをコピーすることは必ずしも悪いことではない</a><a id="データをコピーすることは必ずしも悪いことではない-1"></a><a class="docs-heading-anchor-permalink" href="#データをコピーすることは必ずしも悪いことではない" title="Permalink"></a></h2><p>配列はメモリ内に連続して格納されているため，CPUのベクトル化やキャッシュによるメモリアクセス が少なくなります．これらの理由は，配列に列メジャー順でアクセスすることが推奨されているのと 同じです（上記参照）．不規則なアクセスパターンと非連続ビューは，非連続メモリアクセスのため， 配列上の計算を大幅に遅くする可能性があります．</p><p>不規則にアクセスされたデータを連続する配列にコピーしてから操作すると，以下の例のように， 大幅な高速化が得られます．ここでは行列とベクトルが乗算される前に，ランダムにシャッフル された800,000個のインデックスでアクセスされています．ビューをプレーンな配列にコピーする ことで，コピー操作のコストを払ってでも乗算を高速化することができます．</p><pre><code class="language-julia-repl">julia&gt; using Random

julia&gt; x = randn(1_000_000);

julia&gt; inds = shuffle(1:1_000_000)[1:800000];

julia&gt; A = randn(50, 1_000_000);

julia&gt; xtmp = zeros(800_000);

julia&gt; Atmp = zeros(50, 800_000);

julia&gt; @time sum(view(A, :, inds) * view(x, inds))
  0.412156 seconds (14 allocations: 960 bytes)
-4256.759568345458

julia&gt; @time begin
           copyto!(xtmp, view(x, inds))
           copyto!(Atmp, view(A, :, inds))
           sum(Atmp * xtmp)
       end
  0.285923 seconds (14 allocations: 960 bytes)
-4256.759568345134</code></pre><p>コピーするのに十分なメモリがあれば，ビューを配列にコピーするコストよりも，連続する配列上で 行列の乗算を行うことによる速度の向上の方が勝ります．</p><h2 id="I/Oのための文字列補間を避ける"><a class="docs-heading-anchor" href="#I/Oのための文字列補間を避ける">I/Oのための文字列補間を避ける</a><a id="I/Oのための文字列補間を避ける-1"></a><a class="docs-heading-anchor-permalink" href="#I/Oのための文字列補間を避ける" title="Permalink"></a></h2><p>When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of: ファイル（または他のI/Oデバイス）にデータを書き込む際，余分な中間文字列を形成することは オーバーヘッドの原因となります．以下の式:</p><pre><code class="language-julia">println(file, &quot;$a $b&quot;)</code></pre><p>の代わりに，以下の式を使用してください:</p><pre><code class="language-julia">println(file, a, &quot; &quot;, b)</code></pre><p>最初のバージョンのコードは文字列を形成してからファイルに書き込み，2番目のバージョンは値を 直接ファイルに書き込みます．また場合によっては文字列の補間が読みにくくなることにも注意 してください．以下の2つを比べてみましょう:</p><pre><code class="language-julia">println(file, &quot;$(f(a))$(f(b))&quot;)</code></pre><p>と:</p><pre><code class="language-julia">println(file, f(a), f(b))</code></pre><h2 id="並列実行時のネットワークI/Oの最適化"><a class="docs-heading-anchor" href="#並列実行時のネットワークI/Oの最適化">並列実行時のネットワークI/Oの最適化</a><a id="並列実行時のネットワークI/Oの最適化-1"></a><a class="docs-heading-anchor-permalink" href="#並列実行時のネットワークI/Oの最適化" title="Permalink"></a></h2><p>リモート関数を並列に実行する場合，初めの例:</p><pre><code class="language-julia">using Distributed

responses = Vector{Any}(undef, nworkers())
@sync begin
    for (idx, pid) in enumerate(workers())
        @async responses[idx] = remotecall_fetch(foo, pid, args...)
    end
end</code></pre><p>の方が次の例よりも高速です:</p><pre><code class="language-julia">using Distributed

refs = Vector{Any}(undef, nworkers())
for (idx, pid) in enumerate(workers())
    refs[idx] = @spawnat pid foo(args...)
end
responses = [fetch(r) for r in refs]</code></pre><p>前者は全てのワーカへのネットワークランドトリップが1回になるのに対し，後者は2回のネットワーク コールが発生します．この2回のうち最初は<a href="../stdlib/Distributed.html#Distributed.@spawnat"><code>@spawnat</code></a>によるもの，2回目は<a href="../base/parallel.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> （あるいは<a href="../base/parallel.html#Base.wait"><code>wait</code></a>）によるものです．<a href="../base/parallel.html#Base.fetch-Tuple{Task}"><code>fetch</code></a>/<a href="../base/parallel.html#Base.wait"><code>wait</code></a>もシリアルに実行 されているため，全体的にパフォーマンスが低下してしまいます．</p><h2 id="非推奨の警告を修正する"><a class="docs-heading-anchor" href="#非推奨の警告を修正する">非推奨の警告を修正する</a><a id="非推奨の警告を修正する-1"></a><a class="docs-heading-anchor-permalink" href="#非推奨の警告を修正する" title="Permalink"></a></h2><p>非推奨の関数は，関連する警告を一度だけ表示するために内部的にルックアップを実行します． この余分なルックアップは大幅な速度低下を引き起こす可能性があるため，非推奨関数の使用は 全て，警告で示唆されているように修正しなければなりません．</p><h2 id="調整"><a class="docs-heading-anchor" href="#調整">調整</a><a id="調整-1"></a><a class="docs-heading-anchor-permalink" href="#調整" title="Permalink"></a></h2><p>これらはタイトなインナループに役立つかもしれない細かなポイントです．</p><ul><li>不要な配列を避ける．例えば<a href="../base/collections.html#Base.sum"><code>sum([x,y,z])</code></a>の代わりに<code>x+y+z</code>を使う．</li><li>複素数<code>z</code>の場合は，<a href="../base/math.html#Base.:^-Tuple{Number,Number}"><code>abs(z)^2</code></a>ではなく<a href="../base/math.html#Base.abs2"><code>abs2(z)</code></a>を使う．一般的には，複素数引数に<a href="../base/math.html#Base.abs"><code>abs</code></a>の代わりに<a href="../base/math.html#Base.abs2"><code>abs2</code></a>を使うようにコードを書き換える．</li><li>整数の切り捨て除算には<a href="../base/math.html#Base.trunc"><code>trunc(x/y)</code></a>の代わりに<a href="../base/math.html#Base.div"><code>div(x,y)</code></a>を，<a href="../base/math.html#Base.floor"><code>floor(x/y)</code></a>の代わりに<a href="../base/math.html#Base.fld"><code>fld(x,y)</code></a>を，<a href="../base/math.html#Base.ceil"><code>ceil(x/y)</code></a>の代わりに<a href="../base/math.html#Base.cld"><code>cld(x,y)</code></a>を使うようにする．</li></ul><h2 id="man-performance-annotations"><a class="docs-heading-anchor" href="#man-performance-annotations">パフォーマンスアノテーション</a><a id="man-performance-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-annotations" title="Permalink"></a></h2><p>特定のプログラムのプロパティを約束することで，より良い最適化が可能になることがあります．</p><ul><li><a href="../base/base.html#Base.@inbounds"><code>@inbounds</code></a>を使用して，式内の配列の境界チェックを排除することができます．これを行う前に確認してください．添え字が範囲外になるようなことがあると，クラッシュやサイレント故障が発生する可能性があります．</li><li><a href="../base/math.html#Base.FastMath.@fastmath"><code>@fastmath</code></a>を使用すると，実数では正しい浮動小数点最適化が可能になりますが，IEEE数では違いが生じます．これを行う際には，数値結果が変化する可能性があるので注意してください．これはclangの<code>-ffast-math</code>オプションに相当します．</li><li><code>for</code>ループの前に<a href="../base/base.html#Base.SimdLoop.@simd"><code>@simd</code></a>を書くことで，反復が独立しており，順序を変えても良いことを約束します．多くの場合，Juliaは<code>@simd</code>マクロを使わなくても自動的にコードをベクトル化できることに注意してください．それは，浮動小数点の再関連付けを許可したり依存するメモリアクセスを無視したり（<code>@simd ivdep</code>）するような場合など，そのような変換がイリーガルな場合にのみ有効です．繰り返しになりますが，<code>@simd</code>をアサートする際には非常に注意が必要で，依存関係のあるループに間違ってアノテートしてしまうと予期せぬ結果につながる場合があります．特に，いくつかの<code>AbstractArray</code>サブタイプの<code>setindex!</code>は本質的に反復順序に依存していることに注意してください．<strong>この機能は実験的なもの</strong>であり，将来のJuliaのバージョンでは変更されたり消えたりする可能性があります．</li></ul><p>1:nを使用してAbstractArrayにインデックスを作成するという一般的な慣用句は，配列が一般的でない インデックスを使用している場合には安全ではなく，境界チェックがオフになっている場合にセグメン テーションエラーを引き起こす可能性があります．代わりに<code>LinearIndices(x)</code>または<code>eachindex(x)</code> を使用してください（<a href="../devdocs/offset-arrays.html#man-custom-indices">カスタムインデックスを持つ配列</a>も参照してください）．</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@simd</code>は一番内側の<code>for</code>ループの前に直接配置する必要がありますが，<code>@inbounds</code>や<code>@fastmath</code>はいずれも単一の式，またはコードの入れ子になったブロック内に現れる全ての式に適用できます．（例えば，<code>@inbounds begin</code>や<code>@inbounds for ...</code>を使用するなど）</p></div></div><p>ここでは，<code>@inbounds</code>と<code>@simd</code>の両方をマークアップした例を示します（ここではオプティマイザが 賢くなりすぎてベンチマークを破ろうとするのを防ぐために<code>@noinline</code>を使用しています）:</p><pre><code class="language-julia">@noinline function inner(x, y)
    s = zero(eltype(x))
    for i=eachindex(x)
        @inbounds s += x[i]*y[i]
    end
    return s
end

@noinline function innersimd(x, y)
    s = zero(eltype(x))
    @simd for i = eachindex(x)
        @inbounds s += x[i] * y[i]
    end
    return s
end

function timeit(n, reps)
    x = rand(Float32, n)
    y = rand(Float32, n)
    s = zero(Float64)
    time = @elapsed for j in 1:reps
        s += inner(x, y)
    end
    println(&quot;GFlop/sec        = &quot;, 2n*reps / time*1E-9)
    time = @elapsed for j in 1:reps
        s += innersimd(x, y)
    end
    println(&quot;GFlop/sec (SIMD) = &quot;, 2n*reps / time*1E-9)
end

timeit(1000, 1000)</code></pre><p>2.4GHz Intel Core i5プロセッサを搭載したコンピュータでは，以下のような結果が得られます:</p><pre><code class="language-none">GFlop/sec        = 1.9467069505224963
GFlop/sec (SIMD) = 17.578554163920018</code></pre><p>(<code>GFlop/sec</code> で性能を測定しており，大きいほど良いです．)</p><p>ここでは3種類のマークアップを用いた例を示します．このプログラムはまず一次元配列の有限差分を 計算し，その結果のL2ノルムを評価します:</p><pre><code class="language-julia">function init!(u::Vector)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing
        u[i] = sin(2pi*dx*i)
    end
end

function deriv!(u::Vector, du)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx
    @fastmath @inbounds @simd for i in 2:n-1
        du[i] = (u[i+1] - u[i-1]) / (2*dx)
    end
    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx
end

function mynorm(u::Vector)
    n = length(u)
    T = eltype(u)
    s = zero(T)
    @fastmath @inbounds @simd for i in 1:n
        s += u[i]^2
    end
    @fastmath @inbounds return sqrt(s)
end

function main()
    n = 2000
    u = Vector{Float64}(undef, n)
    init!(u)
    du = similar(u)

    deriv!(u, du)
    nu = mynorm(du)

    @time for i in 1:10^6
        deriv!(u, du)
        nu = mynorm(du)
    end

    println(nu)
end

main()</code></pre><p>2.7GHz Intel Core i7プロセッサ上で実行すると，次のような結果になります:</p><pre><code class="language-none">$ julia wave.jl;
  1.207814709 seconds
4.443986180758249

$ julia --math-mode=ieee wave.jl;
  4.487083643 seconds
4.443986180758249</code></pre><p>ここでは，オプション<code>--math-mode=ieee</code>は<code>@fastmath</code>マクロを無効にしているため，我々は結果を比較することができます．</p><p>この場合，<code>@fastmath</code>による高速化は約3.7倍になります．これは異常に大きいです．一般的には スピードアップはもっと小さくなります．（この特定の例では，ベンチマークの作業セットは プロセッサのL1キャッシュに収まるほど小さいため，メモリアクセスのレイテンシは役割を果たさず， 計算時間はCPU使用率に支配されます．多くの実世界のプログラムではこのようなことはありません．） また，この場合，この最適化を行っても計算結果は変わりません．一般的には，結果はわずかに異なます．場合によっては，特に数値的に不安定なアルゴリズムの場合，結果が大きく異なることがあります．</p><p><code>@fastmath</code>は浮動小数点式を再配置します．例えば評価の順序を変更したり，特定の特殊なケース （inf, nan）が発生しないと仮定したりします．この場合（そしてこの特定のコンピュータでは）， 主な違いは関数<code>deriv</code>の式<code>1 / (2*dx)</code>が，まるで<code>idx = 1 / (2*dx)</code>と書いたかのように， ループの外に持ち出される（つまり，ループの外で計算される）ということです．ループ内では， 式<code>... / (2*dx)</code>は<code>... * idx</code>となり，評価がより速くなり．もちろん，コンパイラによって 適用される実際の最適化とその結果の高速化は，ハードウェアに大きく依存します．生成された コードの変化はJuliaの<a href="../stdlib/InteractiveUtils.html#InteractiveUtils.code_native"><code>code_native</code></a>関数を使って調べることができます．</p><p>また，<code>@fastmath</code>は計算中に<code>NaN</code>sが発生しないことを前提としているため，驚くような動作をする 可能性があることに注意してください．</p><pre><code class="language-julia-repl">julia&gt; f(x) = isnan(x);

julia&gt; f(NaN)
true

julia&gt; f_fast(x) = @fastmath isnan(x);

julia&gt; f_fast(NaN)
false</code></pre><h2 id="非正規化数をゼロとして扱う"><a class="docs-heading-anchor" href="#非正規化数をゼロとして扱う">非正規化数をゼロとして扱う</a><a id="非正規化数をゼロとして扱う-1"></a><a class="docs-heading-anchor-permalink" href="#非正規化数をゼロとして扱う" title="Permalink"></a></h2><p>以前は<a href="https://en.wikipedia.org/ことがwiki/Denormal_number">denormal numbers</a>と呼ばれていた 非正規化数（原文subnormal numbers）は，多くの文脈で有用ですが，ハードウェアによっては パフォーマンスが低下します．<a href="../base/numbers.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(true)</code></a>をコールすると，浮動小数点 演算で非正規化数の入力または出力をゼロとして扱うことができるようになります． <a href="../base/numbers.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(false)</code></a>を呼び出すと，正規化数以下の数値に対しては厳格なIEEEの 動作が強制されます．</p><p>以下に非正規化数が一部のハードウェアで顕著にパフォーマンスに影響を与える例を示します:</p><pre><code class="language-julia">function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T
    @assert length(a)==length(b)
    n = length(b)
    b[1] = 1                            # Boundary condition
    for i=2:n-1
        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt
    end
    b[n] = 0                            # Boundary condition
end

function heatflow(a::Vector{T}, nstep::Integer) where T
    b = similar(a)
    for t=1:div(nstep,2)                # Assume nstep is even
        timestep(b,a,T(0.1))
        timestep(a,b,T(0.1))
    end
end

heatflow(zeros(Float32,10),2)           # Force compilation
for trial=1:6
    a = zeros(Float32,1000)
    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic
    @time heatflow(a,1000)
end</code></pre><p>これにより以下のような結果が得られます．</p><pre><code class="language-none">  0.002202 seconds (1 allocation: 4.063 KiB)
  0.001502 seconds (1 allocation: 4.063 KiB)
  0.002139 seconds (1 allocation: 4.063 KiB)
  0.001454 seconds (1 allocation: 4.063 KiB)
  0.002115 seconds (1 allocation: 4.063 KiB)
  0.001455 seconds (1 allocation: 4.063 KiB)</code></pre><p>偶数回の繰り返しの度に速くなっていることに注目してください．</p><p>この例では，<code>a</code>の値が指数関数的に減少する曲線となり時間の経過とともにゆっくりと平らになるため， 多くの非正規化数が生成されます．</p><p>非正規化数をゼロとして扱うのには注意が必要です．なぜなら<code>x-y == 0</code>が<code>x == y</code>を意味している というような，いくつかの等式関係を破ることになるからです:</p><pre><code class="language-julia-repl">julia&gt; x = 3f-38; y = 2f-38;

julia&gt; set_zero_subnormals(true); (x - y, x == y)
(0.0f0, false)

julia&gt; set_zero_subnormals(false); (x - y, x == y)
(1.0000001f-38, false)</code></pre><p>アプリケーションによっては，非正規化数をゼロにする代わりに，わずかなノイズを注入する こともあります．例えば，<code>a</code>をゼロで初期化する代わりに，以下のようにします:</p><pre><code class="language-julia">a = rand(Float32,1000) * 1.f-9</code></pre><h2 id="man-code-warntype"><a class="docs-heading-anchor" href="#man-code-warntype"><a href="../stdlib/InteractiveUtils.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>マクロ</a><a id="man-code-warntype-1"></a><a class="docs-heading-anchor-permalink" href="#man-code-warntype" title="Permalink"></a></h2><p>マクロ<a href="../stdlib/InteractiveUtils.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>（またはその関数版<a href="../stdlib/InteractiveUtils.html#InteractiveUtils.code_warntype"><code>code_warntype</code></a>）は，型関連の 問題を診断するのに役立つことがあります．ここでは例を示します:</p><pre><code class="language-julia-repl">julia&gt; @noinline pos(x) = x &lt; 0 ? 0 : x;

julia&gt; function f(x)
           y = pos(x)
           return sin(y*x + 1)
       end;

julia&gt; @code_warntype f(3.2)
Variables
  #self#::Core.Compiler.Const(f, false)
  x::Float64
  y::UNION{FLOAT64, INT64}

Body::Float64
1 ─      (y = Main.pos(x))
│   %2 = (y * x)::Float64
│   %3 = (%2 + 1)::Float64
│   %4 = Main.sin(%3)::Float64
└──      return %4</code></pre><p><a href="../stdlib/InteractiveUtils.html#InteractiveUtils.@code_llvm"><code>@code_llvm</code></a>，<a href="../stdlib/InteractiveUtils.html#InteractiveUtils.@code_native"><code>@code_native</code></a>の出力と同様に解釈するには，少し練習が必要です． あなたのコードは，コンパイルされたマシンコードを生成する途中で大きく要約された形で表示され ます．ほとんどの式は型によってアノテーションされており，<code>::T</code>で表されています（ここで，Tは 例えば<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>のようなものです）．<a href="../stdlib/InteractiveUtils.html#InteractiveUtils.@code_warntype"><code>@code_warntype</code></a>の最も重要な特徴は， 具体的でない(non-concrete)型が赤で表示されることです．このドキュメント自体はMarkdownで書かれ ているので，このドキュメントでは赤文字は大見字で書いています．</p><p>上部には，関数の推測される戻り値の型が<code>Body::Float64</code>として表示されています．次の行は， JuliaのSSA IRフォームにおける<code>f</code>のボディを表しています．番号のついたボックスはラベルであり， コード内のジャンプ（<code>goto</code>経由）のターゲットを表しています．ボディを見てみると，まず<code>pos</code>が 呼び出され，戻り値はnon-concrete型であるため，大文字で示された<code>Union</code>型の<code>UNION{FLOAT64, INT64}</code> と推論されていることがわかります．つまり入力された型から<code>pos</code>の正確な戻り値の型を知ることは できません．しかし<code>y*x</code>の結果は，<code>y</code>が<code>Float64</code>であろうと<code>Int64</code>であろうと，関係なく<code>Float64</code> となります．結果として，<code>f(x::Float64)</code>の出力は，たとえ中間の計算の一部が型不安定であったと しても型不安定にはなりません．</p><p>この情報をどのように使うかはあなた次第です．明らかに，<code>pos</code>を型安定な形に直すのが断然最善 です．そうすれば<code>f</code>の全ての変数が具体的(concrete)になり，その性能は最適になります． しかし，このような<em>一時的な</em>型の不安定があまり重要でない状況もあります．例えば，<code>pos</code>を 単独で使用することがない場合，<code>f</code>の出力が（<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>入力に対して）型安定である という事実は，型の不安定性の影響が伝搬することから後のコードを保護します．これは，型の不安定 性を修正することが難しい，あるいは不可能な場合に特に重要です．このような場合には，上記の ヒント（例えば，型のアノテーションを追加したり，関数を分割したりする）が，型の不安定性に よる「ダメージ」をおさえるための最良のツールとなります．また，Julia Baseにも型が不安定な 関数があることにも注意してください．例えば，関数<a href="../base/arrays.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>は，キーが見つかった配列 のインデックスまたは見つからなければ<code>nothing</code>を返しますが，これは明らかに型不安定です． 重要である可能性の高い型の不安定性を見つけやすくするために，<code>missing</code>か<code>nothing</code>を含む <code>Union</code>は赤ではなく黄色で色分けされています．</p><p>以下の例は非リーフ(non-leaf)型を含むとマークされた式を解釈するのに役立つかもしれません:</p><ul><li><p><code>Body::UNION{T1,T2})</code>で始まる関数のボディ</p><ul><li>解釈: 不安定な戻り値を持つ関数</li><li>提案: 返り値を型が安定しているものにします</li></ul></li><li><p><code>invoke Main.g(%%x::Int64)::UNION{FLOAT64, INT64}</code></p><ul><li>解釈: 型不安定な関数<code>g</code>の呼び出し</li><li>提案: 関数を修正するか，必要であれば戻り値にアノテーションをつけます</li></ul></li></ul><ul><li><p><code>invoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::ANY</code></p><ul><li>解釈: 型付けの悪い配列の要素へのアクセス</li><li>提案: より良い定義の型を持つ配列を使用するか，必要に応じて個々の要素のアクセスの型をアノテーションします</li></ul></li><li><p><code>Base.getfield(%%x, :(:data))::ARRAY{FLOAT64,N} WHERE N</code></p><ul><li>解釈: non-leaf型のフィールドを取得しています．この場合<code>ArrayContainer</code>はフィールド<code>data::Array{T}</code>を持っていました．しかし，<code>Array</code>がconcreteな型であるためには次元<code>N</code>も必要です</li><li>提案: <code>Array{T,3}</code>や<code>Array{T,N}</code>（<code>N</code>はここでは<code>ArrayContainer</code>のパラメータです）のようなconcreteな型を使用してください</li></ul></li></ul><h2 id="man-performance-captured"><a class="docs-heading-anchor" href="#man-performance-captured">キャプチャされた変数の性能</a><a id="man-performance-captured-1"></a><a class="docs-heading-anchor-permalink" href="#man-performance-captured" title="Permalink"></a></h2><p>内部関数を定義する次の例を考えてみましょう:</p><pre><code class="language-julia">function abmult(r::Int)
    if r &lt; 0
        r = -r
    end
    f = x -&gt; x * r
    return f
end</code></pre><p>関数<code>abmult</code>は，引数に<code>r</code>の絶対値を乗算する関数<code>f</code>を返します．<code>f</code>に割り当てられた 内部関数は「クロージャ」と呼ばれます．内部関数は<code>do</code>ブロックやジェネレータ式にも 使用されます．</p><p>このコードスタイルは，言語のパフォーマンスに課題があります．パーサは，これを低レベル命令 に変換する際に，内部関数を別のコードブロックに抽出することで，上記のコード大幅に再編成 します．内部関数とそれを囲むスコープで共有されている<code>r</code>のような「キャプチャ」された変数 もまた，ヒープに割り当てられた「ボックス」に抽出され，内部スコープ内の<code>r</code>は外部スコープ （または別の内部関数）が<code>r</code>を変更した後でも，外部スコープ内の<code>r</code>と同一でならなければ ならないことが言語で指定されているため，内部関数と外部関数の両方からアクセス可能です．</p><p>前の段ランクの議論では「パーサ」，つまり<code>abmult</code>を含むモジュールが最初にロードされた時に 行われるコンパイルの段階について言及しましたが，それは最初に呼び出されたときの後の段階とは 対照的です．パーサは<code>Int</code>が固定された型であることや，<code>r = -r</code>が<code>Int</code>を別の<code>Int</code>に変換する ことを「知っている」わけではありません．型推論の魔法はコンパイルの後の段階で行われます．</p><p>したがって，パーサは<code>r</code>が固定型（<code>Int</code>)であることを知りませんし，（ボックスが不要になるように） 内部関数が作成されても<code>r</code>が値を変更しないことも知りません．したがって，パーサは<code>Any</code>などの <code>r</code>の出現ごとにランタイム型ディスパッチが必要になるような抽象型を持つオブジェクトを保持して いるボックスのコードを出力します．これは上記の関数に<code>@code_warntype</code>を適用することで検証 できます．ボックス化とランタイム型ディスパッチの両方がパフォーマンスの低下を引き起こす可能性 があります．</p><p>キャプチャされた変数がコードのパフォーマンスクリティカルなセクションで使用されている場合， 以下のヒントはそれらの使用がパフォーマンスを発揮することの保証に役立ちます．最初に， キャプチャされた変数がその方を変更しないことがわかっている場合，これは型アノテーションで 明示的に宣言することができます（変数の右側ではなく，変数の上で）:</p><pre><code class="language-julia">function abmult2(r0::Int)
    r::Int = r0
    if r &lt; 0
        r = -r
    end
    f = x -&gt; x * r
    return f
end</code></pre><p>型アノテーションは，パーサがボックス内のオブジェクトにconcreteな型を関連付けることができる ので，キャプチャによるパフォーマンスの低下を部分的に回復します．さらに，キャプチャされた 変数をボックスに入れる必要がない場合，（クロージャが作成された後に再割り当てされないため）， 次のように<code>let</code>ブロックを使用して表示することができます．</p><pre><code class="language-julia">function abmult3(r::Int)
    if r &lt; 0
        r = -r
    end
    f = let r = r
            x -&gt; x * r
    end
    return f
end</code></pre><p><code>let</code>ブロックは，スコープが内部関数のみである新しい変数<code>r</code>を作成します．2番目のテクニック は，キャプチャされた変数の存在下で完全な言語性能を回復します．これはコンパイラの急速に進化 している側面であり，将来のリリースではし恵能を達成するためにプログラムがこの程度の アノテーションを必要としなくなる可能性があることに注意してください．その間に， <a href="https://github.com/c42f/FastClosures.jl">FastClosures</a>のようなユーザが貢献している パッケージでは，<code>abmult3</code>のように<code>let</code>文の挿入を自動化しています．</p><h1 id="シングルトンでの同等性のチェック"><a class="docs-heading-anchor" href="#シングルトンでの同等性のチェック">シングルトンでの同等性のチェック</a><a id="シングルトンでの同等性のチェック-1"></a><a class="docs-heading-anchor-permalink" href="#シングルトンでの同等性のチェック" title="Permalink"></a></h1><p>ある値がシングルトンと等しいかどうかをチェックする時は，イコール(<code>==</code>)ではなく 同一性(<code>===</code>)をチェックした方が性能的に良い場合があります．同じアドバイスが， <code>!=</code>よりも<code>!==</code>を使う場合にも当てはまります．この種のチェックは，例えば，反復 処理プロトコルを実装していて，<a href="../base/collections.html#Base.iterate"><code>iterate</code></a>から<code>nothing</code>が返ってくるかどうか をチェックするときなどに頻繁に発生します．</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="stacktraces.html">« Stack Traces</a><a class="docs-footer-nextpage" href="workflow-tips.html">Workflow Tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 15 February 2021 22:42">Monday 15 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
